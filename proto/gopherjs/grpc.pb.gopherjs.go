// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: grpc.proto

/*
	Package P4wnP1_grpc is a generated protocol buffer package.

	It is generated from these files:
		grpc.proto

	It has these top-level messages:
		WiFiSettings
		WiFiState
		WiFiBSSCfg
		StringMessage
		EventRequest
		EventValue
		Event
		TempDirOrFileRequest
		TempDirOrFileResponse
		ReadFileRequest
		ReadFileResponse
		WriteFileRequest
		FileInfoRequest
		FileInfoResponse
		HIDScriptRequest
		HIDScriptJob
		HIDScriptJobList
		HIDRunningJobStateResult
		HIDScriptResult
		LEDSettings
		GadgetSettings
		GadgetSettingsEthernet
		GadgetSettingsUMS
		DeployedEthernetInterfaceSettings
		EthernetInterfaceSettings
		DHCPServerSettings
		DHCPServerRange
		DHCPServerStaticHost
		Empty
*/
package P4wnP1_grpc

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

// WiFi2 (distinguish state and settings)
type WiFiWorkingMode int

const (
	WiFiWorkingMode_UNKNOWN         WiFiWorkingMode = 0
	WiFiWorkingMode_AP              WiFiWorkingMode = 1
	WiFiWorkingMode_STA             WiFiWorkingMode = 2
	WiFiWorkingMode_STA_FAILOVER_AP WiFiWorkingMode = 3
)

var WiFiWorkingMode_name = map[int]string{
	0: "UNKNOWN",
	1: "AP",
	2: "STA",
	3: "STA_FAILOVER_AP",
}
var WiFiWorkingMode_value = map[string]int{
	"UNKNOWN":         0,
	"AP":              1,
	"STA":             2,
	"STA_FAILOVER_AP": 3,
}

func (x WiFiWorkingMode) String() string {
	return WiFiWorkingMode_name[int(x)]
}

type WiFiAuthMode int

const (
	WiFiAuthMode_WPA2_PSK WiFiAuthMode = 0
	WiFiAuthMode_OPEN     WiFiAuthMode = 1
)

var WiFiAuthMode_name = map[int]string{
	0: "WPA2_PSK",
	1: "OPEN",
}
var WiFiAuthMode_value = map[string]int{
	"WPA2_PSK": 0,
	"OPEN":     1,
}

func (x WiFiAuthMode) String() string {
	return WiFiAuthMode_name[int(x)]
}

type EthernetInterfaceSettings_Mode int

const (
	EthernetInterfaceSettings_MANUAL      EthernetInterfaceSettings_Mode = 0
	EthernetInterfaceSettings_DHCP_CLIENT EthernetInterfaceSettings_Mode = 1
	EthernetInterfaceSettings_DHCP_SERVER EthernetInterfaceSettings_Mode = 2
	EthernetInterfaceSettings_UNMANAGED   EthernetInterfaceSettings_Mode = 3
)

var EthernetInterfaceSettings_Mode_name = map[int]string{
	0: "MANUAL",
	1: "DHCP_CLIENT",
	2: "DHCP_SERVER",
	3: "UNMANAGED",
}
var EthernetInterfaceSettings_Mode_value = map[string]int{
	"MANUAL":      0,
	"DHCP_CLIENT": 1,
	"DHCP_SERVER": 2,
	"UNMANAGED":   3,
}

func (x EthernetInterfaceSettings_Mode) String() string {
	return EthernetInterfaceSettings_Mode_name[int(x)]
}

type WiFiSettings struct {
	// Generic
	Name           string
	Disabled       bool
	Regulatory     string
	WorkingMode    WiFiWorkingMode
	AuthMode       WiFiAuthMode
	Channel        uint32
	Ap_BSS         *WiFiBSSCfg
	Client_BSSList []*WiFiBSSCfg
	HideSsid       bool
	Nexmon         bool
}

// GetName gets the Name of the WiFiSettings.
func (m *WiFiSettings) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetDisabled gets the Disabled of the WiFiSettings.
func (m *WiFiSettings) GetDisabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Disabled
}

// GetRegulatory gets the Regulatory of the WiFiSettings.
func (m *WiFiSettings) GetRegulatory() (x string) {
	if m == nil {
		return x
	}
	return m.Regulatory
}

// GetWorkingMode gets the WorkingMode of the WiFiSettings.
func (m *WiFiSettings) GetWorkingMode() (x WiFiWorkingMode) {
	if m == nil {
		return x
	}
	return m.WorkingMode
}

// GetAuthMode gets the AuthMode of the WiFiSettings.
func (m *WiFiSettings) GetAuthMode() (x WiFiAuthMode) {
	if m == nil {
		return x
	}
	return m.AuthMode
}

// GetChannel gets the Channel of the WiFiSettings.
func (m *WiFiSettings) GetChannel() (x uint32) {
	if m == nil {
		return x
	}
	return m.Channel
}

// GetAp_BSS gets the Ap_BSS of the WiFiSettings.
func (m *WiFiSettings) GetAp_BSS() (x *WiFiBSSCfg) {
	if m == nil {
		return x
	}
	return m.Ap_BSS
}

// GetClient_BSSList gets the Client_BSSList of the WiFiSettings.
func (m *WiFiSettings) GetClient_BSSList() (x []*WiFiBSSCfg) {
	if m == nil {
		return x
	}
	return m.Client_BSSList
}

// GetHideSsid gets the HideSsid of the WiFiSettings.
func (m *WiFiSettings) GetHideSsid() (x bool) {
	if m == nil {
		return x
	}
	return m.HideSsid
}

// GetNexmon gets the Nexmon of the WiFiSettings.
func (m *WiFiSettings) GetNexmon() (x bool) {
	if m == nil {
		return x
	}
	return m.Nexmon
}

// MarshalToWriter marshals WiFiSettings to the provided writer.
func (m *WiFiSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Name) > 0 {
		writer.WriteString(1, m.Name)
	}

	if m.Disabled {
		writer.WriteBool(2, m.Disabled)
	}

	if len(m.Regulatory) > 0 {
		writer.WriteString(3, m.Regulatory)
	}

	if int(m.WorkingMode) != 0 {
		writer.WriteEnum(4, int(m.WorkingMode))
	}

	if int(m.AuthMode) != 0 {
		writer.WriteEnum(5, int(m.AuthMode))
	}

	if m.Channel != 0 {
		writer.WriteUint32(6, m.Channel)
	}

	if m.Ap_BSS != nil {
		writer.WriteMessage(7, func() {
			m.Ap_BSS.MarshalToWriter(writer)
		})
	}

	for _, msg := range m.Client_BSSList {
		writer.WriteMessage(8, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if m.HideSsid {
		writer.WriteBool(9, m.HideSsid)
	}

	if m.Nexmon {
		writer.WriteBool(13, m.Nexmon)
	}

	return
}

// Marshal marshals WiFiSettings to a slice of bytes.
func (m *WiFiSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WiFiSettings from the provided reader.
func (m *WiFiSettings) UnmarshalFromReader(reader jspb.Reader) *WiFiSettings {
	for reader.Next() {
		if m == nil {
			m = &WiFiSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Name = reader.ReadString()
		case 2:
			m.Disabled = reader.ReadBool()
		case 3:
			m.Regulatory = reader.ReadString()
		case 4:
			m.WorkingMode = WiFiWorkingMode(reader.ReadEnum())
		case 5:
			m.AuthMode = WiFiAuthMode(reader.ReadEnum())
		case 6:
			m.Channel = reader.ReadUint32()
		case 7:
			reader.ReadMessage(func() {
				m.Ap_BSS = m.Ap_BSS.UnmarshalFromReader(reader)
			})
		case 8:
			reader.ReadMessage(func() {
				m.Client_BSSList = append(m.Client_BSSList, new(WiFiBSSCfg).UnmarshalFromReader(reader))
			})
		case 9:
			m.HideSsid = reader.ReadBool()
		case 13:
			m.Nexmon = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WiFiSettings from a slice of bytes.
func (m *WiFiSettings) Unmarshal(rawBytes []byte) (*WiFiSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type WiFiState struct {
	WorkingMode     WiFiWorkingMode
	AuthMode        WiFiAuthMode
	Channel         uint32
	Bss             *WiFiBSSCfg
	CurrentSettings *WiFiSettings
}

// GetWorkingMode gets the WorkingMode of the WiFiState.
func (m *WiFiState) GetWorkingMode() (x WiFiWorkingMode) {
	if m == nil {
		return x
	}
	return m.WorkingMode
}

// GetAuthMode gets the AuthMode of the WiFiState.
func (m *WiFiState) GetAuthMode() (x WiFiAuthMode) {
	if m == nil {
		return x
	}
	return m.AuthMode
}

// GetChannel gets the Channel of the WiFiState.
func (m *WiFiState) GetChannel() (x uint32) {
	if m == nil {
		return x
	}
	return m.Channel
}

// GetBss gets the Bss of the WiFiState.
func (m *WiFiState) GetBss() (x *WiFiBSSCfg) {
	if m == nil {
		return x
	}
	return m.Bss
}

// GetCurrentSettings gets the CurrentSettings of the WiFiState.
func (m *WiFiState) GetCurrentSettings() (x *WiFiSettings) {
	if m == nil {
		return x
	}
	return m.CurrentSettings
}

// MarshalToWriter marshals WiFiState to the provided writer.
func (m *WiFiState) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if int(m.WorkingMode) != 0 {
		writer.WriteEnum(1, int(m.WorkingMode))
	}

	if int(m.AuthMode) != 0 {
		writer.WriteEnum(2, int(m.AuthMode))
	}

	if m.Channel != 0 {
		writer.WriteUint32(3, m.Channel)
	}

	if m.Bss != nil {
		writer.WriteMessage(4, func() {
			m.Bss.MarshalToWriter(writer)
		})
	}

	if m.CurrentSettings != nil {
		writer.WriteMessage(5, func() {
			m.CurrentSettings.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals WiFiState to a slice of bytes.
func (m *WiFiState) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WiFiState from the provided reader.
func (m *WiFiState) UnmarshalFromReader(reader jspb.Reader) *WiFiState {
	for reader.Next() {
		if m == nil {
			m = &WiFiState{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.WorkingMode = WiFiWorkingMode(reader.ReadEnum())
		case 2:
			m.AuthMode = WiFiAuthMode(reader.ReadEnum())
		case 3:
			m.Channel = reader.ReadUint32()
		case 4:
			reader.ReadMessage(func() {
				m.Bss = m.Bss.UnmarshalFromReader(reader)
			})
		case 5:
			reader.ReadMessage(func() {
				m.CurrentSettings = m.CurrentSettings.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WiFiState from a slice of bytes.
func (m *WiFiState) Unmarshal(rawBytes []byte) (*WiFiState, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type WiFiBSSCfg struct {
	SSID string
	PSK  string
}

// GetSSID gets the SSID of the WiFiBSSCfg.
func (m *WiFiBSSCfg) GetSSID() (x string) {
	if m == nil {
		return x
	}
	return m.SSID
}

// GetPSK gets the PSK of the WiFiBSSCfg.
func (m *WiFiBSSCfg) GetPSK() (x string) {
	if m == nil {
		return x
	}
	return m.PSK
}

// MarshalToWriter marshals WiFiBSSCfg to the provided writer.
func (m *WiFiBSSCfg) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.SSID) > 0 {
		writer.WriteString(1, m.SSID)
	}

	if len(m.PSK) > 0 {
		writer.WriteString(2, m.PSK)
	}

	return
}

// Marshal marshals WiFiBSSCfg to a slice of bytes.
func (m *WiFiBSSCfg) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WiFiBSSCfg from the provided reader.
func (m *WiFiBSSCfg) UnmarshalFromReader(reader jspb.Reader) *WiFiBSSCfg {
	for reader.Next() {
		if m == nil {
			m = &WiFiBSSCfg{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.SSID = reader.ReadString()
		case 2:
			m.PSK = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WiFiBSSCfg from a slice of bytes.
func (m *WiFiBSSCfg) Unmarshal(rawBytes []byte) (*WiFiBSSCfg, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Alive check
type StringMessage struct {
	Msg string
}

// GetMsg gets the Msg of the StringMessage.
func (m *StringMessage) GetMsg() (x string) {
	if m == nil {
		return x
	}
	return m.Msg
}

// MarshalToWriter marshals StringMessage to the provided writer.
func (m *StringMessage) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Msg) > 0 {
		writer.WriteString(1, m.Msg)
	}

	return
}

// Marshal marshals StringMessage to a slice of bytes.
func (m *StringMessage) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a StringMessage from the provided reader.
func (m *StringMessage) UnmarshalFromReader(reader jspb.Reader) *StringMessage {
	for reader.Next() {
		if m == nil {
			m = &StringMessage{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Msg = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a StringMessage from a slice of bytes.
func (m *StringMessage) Unmarshal(rawBytes []byte) (*StringMessage, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Events
type EventRequest struct {
	ListenType int64
}

// GetListenType gets the ListenType of the EventRequest.
func (m *EventRequest) GetListenType() (x int64) {
	if m == nil {
		return x
	}
	return m.ListenType
}

// MarshalToWriter marshals EventRequest to the provided writer.
func (m *EventRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ListenType != 0 {
		writer.WriteInt64(1, m.ListenType)
	}

	return
}

// Marshal marshals EventRequest to a slice of bytes.
func (m *EventRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EventRequest from the provided reader.
func (m *EventRequest) UnmarshalFromReader(reader jspb.Reader) *EventRequest {
	for reader.Next() {
		if m == nil {
			m = &EventRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ListenType = reader.ReadInt64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EventRequest from a slice of bytes.
func (m *EventRequest) Unmarshal(rawBytes []byte) (*EventRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EventValue struct {
	// Types that are valid to be assigned to Val:
	//	*EventValue_Tstring
	//	*EventValue_Tbool
	//	*EventValue_Tint64
	Val isEventValue_Val
}

// isEventValue_Val is used to distinguish types assignable to Val
type isEventValue_Val interface{ isEventValue_Val() }

// EventValue_Tstring is assignable to Val
type EventValue_Tstring struct {
	Tstring string
}

// EventValue_Tbool is assignable to Val
type EventValue_Tbool struct {
	Tbool bool
}

// EventValue_Tint64 is assignable to Val
type EventValue_Tint64 struct {
	Tint64 int64
}

func (*EventValue_Tstring) isEventValue_Val() {}
func (*EventValue_Tbool) isEventValue_Val()   {}
func (*EventValue_Tint64) isEventValue_Val()  {}

// GetVal gets the Val of the EventValue.
func (m *EventValue) GetVal() (x isEventValue_Val) {
	if m == nil {
		return x
	}
	return m.Val
}

// GetTstring gets the Tstring of the EventValue.
func (m *EventValue) GetTstring() (x string) {
	if v, ok := m.GetVal().(*EventValue_Tstring); ok {
		return v.Tstring
	}
	return x
}

// GetTbool gets the Tbool of the EventValue.
func (m *EventValue) GetTbool() (x bool) {
	if v, ok := m.GetVal().(*EventValue_Tbool); ok {
		return v.Tbool
	}
	return x
}

// GetTint64 gets the Tint64 of the EventValue.
func (m *EventValue) GetTint64() (x int64) {
	if v, ok := m.GetVal().(*EventValue_Tint64); ok {
		return v.Tint64
	}
	return x
}

// MarshalToWriter marshals EventValue to the provided writer.
func (m *EventValue) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	switch t := m.Val.(type) {
	case *EventValue_Tstring:
		if len(t.Tstring) > 0 {
			writer.WriteString(1, t.Tstring)
		}
	case *EventValue_Tbool:
		if t.Tbool {
			writer.WriteBool(2, t.Tbool)
		}
	case *EventValue_Tint64:
		if t.Tint64 != 0 {
			writer.WriteInt64(3, t.Tint64)
		}
	}

	return
}

// Marshal marshals EventValue to a slice of bytes.
func (m *EventValue) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EventValue from the provided reader.
func (m *EventValue) UnmarshalFromReader(reader jspb.Reader) *EventValue {
	for reader.Next() {
		if m == nil {
			m = &EventValue{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Val = &EventValue_Tstring{
				Tstring: reader.ReadString(),
			}
		case 2:
			m.Val = &EventValue_Tbool{
				Tbool: reader.ReadBool(),
			}
		case 3:
			m.Val = &EventValue_Tint64{
				Tint64: reader.ReadInt64(),
			}
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EventValue from a slice of bytes.
func (m *EventValue) Unmarshal(rawBytes []byte) (*EventValue, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Event struct {
	Type   int64
	Values []*EventValue
}

// GetType gets the Type of the Event.
func (m *Event) GetType() (x int64) {
	if m == nil {
		return x
	}
	return m.Type
}

// GetValues gets the Values of the Event.
func (m *Event) GetValues() (x []*EventValue) {
	if m == nil {
		return x
	}
	return m.Values
}

// MarshalToWriter marshals Event to the provided writer.
func (m *Event) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Type != 0 {
		writer.WriteInt64(1, m.Type)
	}

	for _, msg := range m.Values {
		writer.WriteMessage(2, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals Event to a slice of bytes.
func (m *Event) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Event from the provided reader.
func (m *Event) UnmarshalFromReader(reader jspb.Reader) *Event {
	for reader.Next() {
		if m == nil {
			m = &Event{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Type = reader.ReadInt64()
		case 2:
			reader.ReadMessage(func() {
				m.Values = append(m.Values, new(EventValue).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Event from a slice of bytes.
func (m *Event) Unmarshal(rawBytes []byte) (*Event, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// File System
type TempDirOrFileRequest struct {
	Dir        string
	Prefix     string
	OnlyFolder bool
}

// GetDir gets the Dir of the TempDirOrFileRequest.
func (m *TempDirOrFileRequest) GetDir() (x string) {
	if m == nil {
		return x
	}
	return m.Dir
}

// GetPrefix gets the Prefix of the TempDirOrFileRequest.
func (m *TempDirOrFileRequest) GetPrefix() (x string) {
	if m == nil {
		return x
	}
	return m.Prefix
}

// GetOnlyFolder gets the OnlyFolder of the TempDirOrFileRequest.
func (m *TempDirOrFileRequest) GetOnlyFolder() (x bool) {
	if m == nil {
		return x
	}
	return m.OnlyFolder
}

// MarshalToWriter marshals TempDirOrFileRequest to the provided writer.
func (m *TempDirOrFileRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Dir) > 0 {
		writer.WriteString(1, m.Dir)
	}

	if len(m.Prefix) > 0 {
		writer.WriteString(2, m.Prefix)
	}

	if m.OnlyFolder {
		writer.WriteBool(3, m.OnlyFolder)
	}

	return
}

// Marshal marshals TempDirOrFileRequest to a slice of bytes.
func (m *TempDirOrFileRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TempDirOrFileRequest from the provided reader.
func (m *TempDirOrFileRequest) UnmarshalFromReader(reader jspb.Reader) *TempDirOrFileRequest {
	for reader.Next() {
		if m == nil {
			m = &TempDirOrFileRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Dir = reader.ReadString()
		case 2:
			m.Prefix = reader.ReadString()
		case 3:
			m.OnlyFolder = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TempDirOrFileRequest from a slice of bytes.
func (m *TempDirOrFileRequest) Unmarshal(rawBytes []byte) (*TempDirOrFileRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type TempDirOrFileResponse struct {
	ResultPath string
}

// GetResultPath gets the ResultPath of the TempDirOrFileResponse.
func (m *TempDirOrFileResponse) GetResultPath() (x string) {
	if m == nil {
		return x
	}
	return m.ResultPath
}

// MarshalToWriter marshals TempDirOrFileResponse to the provided writer.
func (m *TempDirOrFileResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.ResultPath) > 0 {
		writer.WriteString(1, m.ResultPath)
	}

	return
}

// Marshal marshals TempDirOrFileResponse to a slice of bytes.
func (m *TempDirOrFileResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TempDirOrFileResponse from the provided reader.
func (m *TempDirOrFileResponse) UnmarshalFromReader(reader jspb.Reader) *TempDirOrFileResponse {
	for reader.Next() {
		if m == nil {
			m = &TempDirOrFileResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ResultPath = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TempDirOrFileResponse from a slice of bytes.
func (m *TempDirOrFileResponse) Unmarshal(rawBytes []byte) (*TempDirOrFileResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ReadFileRequest struct {
	Path  string
	Start int64
	Data  []byte
}

// GetPath gets the Path of the ReadFileRequest.
func (m *ReadFileRequest) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// GetStart gets the Start of the ReadFileRequest.
func (m *ReadFileRequest) GetStart() (x int64) {
	if m == nil {
		return x
	}
	return m.Start
}

// GetData gets the Data of the ReadFileRequest.
func (m *ReadFileRequest) GetData() (x []byte) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals ReadFileRequest to the provided writer.
func (m *ReadFileRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	if m.Start != 0 {
		writer.WriteInt64(2, m.Start)
	}

	if len(m.Data) > 0 {
		writer.WriteBytes(3, m.Data)
	}

	return
}

// Marshal marshals ReadFileRequest to a slice of bytes.
func (m *ReadFileRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ReadFileRequest from the provided reader.
func (m *ReadFileRequest) UnmarshalFromReader(reader jspb.Reader) *ReadFileRequest {
	for reader.Next() {
		if m == nil {
			m = &ReadFileRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		case 2:
			m.Start = reader.ReadInt64()
		case 3:
			m.Data = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ReadFileRequest from a slice of bytes.
func (m *ReadFileRequest) Unmarshal(rawBytes []byte) (*ReadFileRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ReadFileResponse struct {
	ReadCount int64
}

// GetReadCount gets the ReadCount of the ReadFileResponse.
func (m *ReadFileResponse) GetReadCount() (x int64) {
	if m == nil {
		return x
	}
	return m.ReadCount
}

// MarshalToWriter marshals ReadFileResponse to the provided writer.
func (m *ReadFileResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ReadCount != 0 {
		writer.WriteInt64(1, m.ReadCount)
	}

	return
}

// Marshal marshals ReadFileResponse to a slice of bytes.
func (m *ReadFileResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ReadFileResponse from the provided reader.
func (m *ReadFileResponse) UnmarshalFromReader(reader jspb.Reader) *ReadFileResponse {
	for reader.Next() {
		if m == nil {
			m = &ReadFileResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ReadCount = reader.ReadInt64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ReadFileResponse from a slice of bytes.
func (m *ReadFileResponse) Unmarshal(rawBytes []byte) (*ReadFileResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type WriteFileRequest struct {
	Path         string
	Append       bool
	MustNotExist bool
	Data         []byte
}

// GetPath gets the Path of the WriteFileRequest.
func (m *WriteFileRequest) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// GetAppend gets the Append of the WriteFileRequest.
func (m *WriteFileRequest) GetAppend() (x bool) {
	if m == nil {
		return x
	}
	return m.Append
}

// GetMustNotExist gets the MustNotExist of the WriteFileRequest.
func (m *WriteFileRequest) GetMustNotExist() (x bool) {
	if m == nil {
		return x
	}
	return m.MustNotExist
}

// GetData gets the Data of the WriteFileRequest.
func (m *WriteFileRequest) GetData() (x []byte) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals WriteFileRequest to the provided writer.
func (m *WriteFileRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	if m.Append {
		writer.WriteBool(2, m.Append)
	}

	if m.MustNotExist {
		writer.WriteBool(3, m.MustNotExist)
	}

	if len(m.Data) > 0 {
		writer.WriteBytes(4, m.Data)
	}

	return
}

// Marshal marshals WriteFileRequest to a slice of bytes.
func (m *WriteFileRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WriteFileRequest from the provided reader.
func (m *WriteFileRequest) UnmarshalFromReader(reader jspb.Reader) *WriteFileRequest {
	for reader.Next() {
		if m == nil {
			m = &WriteFileRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		case 2:
			m.Append = reader.ReadBool()
		case 3:
			m.MustNotExist = reader.ReadBool()
		case 4:
			m.Data = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WriteFileRequest from a slice of bytes.
func (m *WriteFileRequest) Unmarshal(rawBytes []byte) (*WriteFileRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type FileInfoRequest struct {
	Path string
}

// GetPath gets the Path of the FileInfoRequest.
func (m *FileInfoRequest) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// MarshalToWriter marshals FileInfoRequest to the provided writer.
func (m *FileInfoRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	return
}

// Marshal marshals FileInfoRequest to a slice of bytes.
func (m *FileInfoRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a FileInfoRequest from the provided reader.
func (m *FileInfoRequest) UnmarshalFromReader(reader jspb.Reader) *FileInfoRequest {
	for reader.Next() {
		if m == nil {
			m = &FileInfoRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a FileInfoRequest from a slice of bytes.
func (m *FileInfoRequest) Unmarshal(rawBytes []byte) (*FileInfoRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type FileInfoResponse struct {
	Name    string
	Size    int64
	Mode    uint32
	ModTime int64
	IsDir   bool
}

// GetName gets the Name of the FileInfoResponse.
func (m *FileInfoResponse) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetSize gets the Size of the FileInfoResponse.
func (m *FileInfoResponse) GetSize() (x int64) {
	if m == nil {
		return x
	}
	return m.Size
}

// GetMode gets the Mode of the FileInfoResponse.
func (m *FileInfoResponse) GetMode() (x uint32) {
	if m == nil {
		return x
	}
	return m.Mode
}

// GetModTime gets the ModTime of the FileInfoResponse.
func (m *FileInfoResponse) GetModTime() (x int64) {
	if m == nil {
		return x
	}
	return m.ModTime
}

// GetIsDir gets the IsDir of the FileInfoResponse.
func (m *FileInfoResponse) GetIsDir() (x bool) {
	if m == nil {
		return x
	}
	return m.IsDir
}

// MarshalToWriter marshals FileInfoResponse to the provided writer.
func (m *FileInfoResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Name) > 0 {
		writer.WriteString(1, m.Name)
	}

	if m.Size != 0 {
		writer.WriteInt64(2, m.Size)
	}

	if m.Mode != 0 {
		writer.WriteUint32(3, m.Mode)
	}

	if m.ModTime != 0 {
		writer.WriteInt64(4, m.ModTime)
	}

	if m.IsDir {
		writer.WriteBool(5, m.IsDir)
	}

	return
}

// Marshal marshals FileInfoResponse to a slice of bytes.
func (m *FileInfoResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a FileInfoResponse from the provided reader.
func (m *FileInfoResponse) UnmarshalFromReader(reader jspb.Reader) *FileInfoResponse {
	for reader.Next() {
		if m == nil {
			m = &FileInfoResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Name = reader.ReadString()
		case 2:
			m.Size = reader.ReadInt64()
		case 3:
			m.Mode = reader.ReadUint32()
		case 4:
			m.ModTime = reader.ReadInt64()
		case 5:
			m.IsDir = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a FileInfoResponse from a slice of bytes.
func (m *FileInfoResponse) Unmarshal(rawBytes []byte) (*FileInfoResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// HID
type HIDScriptRequest struct {
	ScriptPath     string
	TimeoutSeconds uint32
}

// GetScriptPath gets the ScriptPath of the HIDScriptRequest.
func (m *HIDScriptRequest) GetScriptPath() (x string) {
	if m == nil {
		return x
	}
	return m.ScriptPath
}

// GetTimeoutSeconds gets the TimeoutSeconds of the HIDScriptRequest.
func (m *HIDScriptRequest) GetTimeoutSeconds() (x uint32) {
	if m == nil {
		return x
	}
	return m.TimeoutSeconds
}

// MarshalToWriter marshals HIDScriptRequest to the provided writer.
func (m *HIDScriptRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.ScriptPath) > 0 {
		writer.WriteString(1, m.ScriptPath)
	}

	if m.TimeoutSeconds != 0 {
		writer.WriteUint32(2, m.TimeoutSeconds)
	}

	return
}

// Marshal marshals HIDScriptRequest to a slice of bytes.
func (m *HIDScriptRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDScriptRequest from the provided reader.
func (m *HIDScriptRequest) UnmarshalFromReader(reader jspb.Reader) *HIDScriptRequest {
	for reader.Next() {
		if m == nil {
			m = &HIDScriptRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ScriptPath = reader.ReadString()
		case 2:
			m.TimeoutSeconds = reader.ReadUint32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDScriptRequest from a slice of bytes.
func (m *HIDScriptRequest) Unmarshal(rawBytes []byte) (*HIDScriptRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HIDScriptJob struct {
	Id uint32
}

// GetId gets the Id of the HIDScriptJob.
func (m *HIDScriptJob) GetId() (x uint32) {
	if m == nil {
		return x
	}
	return m.Id
}

// MarshalToWriter marshals HIDScriptJob to the provided writer.
func (m *HIDScriptJob) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Id != 0 {
		writer.WriteUint32(1, m.Id)
	}

	return
}

// Marshal marshals HIDScriptJob to a slice of bytes.
func (m *HIDScriptJob) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDScriptJob from the provided reader.
func (m *HIDScriptJob) UnmarshalFromReader(reader jspb.Reader) *HIDScriptJob {
	for reader.Next() {
		if m == nil {
			m = &HIDScriptJob{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Id = reader.ReadUint32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDScriptJob from a slice of bytes.
func (m *HIDScriptJob) Unmarshal(rawBytes []byte) (*HIDScriptJob, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HIDScriptJobList struct {
	Ids []uint32
}

// GetIds gets the Ids of the HIDScriptJobList.
func (m *HIDScriptJobList) GetIds() (x []uint32) {
	if m == nil {
		return x
	}
	return m.Ids
}

// MarshalToWriter marshals HIDScriptJobList to the provided writer.
func (m *HIDScriptJobList) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Ids) > 0 {
		writer.WriteUint32Slice(1, m.Ids)
	}

	return
}

// Marshal marshals HIDScriptJobList to a slice of bytes.
func (m *HIDScriptJobList) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDScriptJobList from the provided reader.
func (m *HIDScriptJobList) UnmarshalFromReader(reader jspb.Reader) *HIDScriptJobList {
	for reader.Next() {
		if m == nil {
			m = &HIDScriptJobList{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Ids = reader.ReadUint32Slice()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDScriptJobList from a slice of bytes.
func (m *HIDScriptJobList) Unmarshal(rawBytes []byte) (*HIDScriptJobList, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HIDRunningJobStateResult struct {
	Id     int64
	VmId   int64
	Source string
}

// GetId gets the Id of the HIDRunningJobStateResult.
func (m *HIDRunningJobStateResult) GetId() (x int64) {
	if m == nil {
		return x
	}
	return m.Id
}

// GetVmId gets the VmId of the HIDRunningJobStateResult.
func (m *HIDRunningJobStateResult) GetVmId() (x int64) {
	if m == nil {
		return x
	}
	return m.VmId
}

// GetSource gets the Source of the HIDRunningJobStateResult.
func (m *HIDRunningJobStateResult) GetSource() (x string) {
	if m == nil {
		return x
	}
	return m.Source
}

// MarshalToWriter marshals HIDRunningJobStateResult to the provided writer.
func (m *HIDRunningJobStateResult) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Id != 0 {
		writer.WriteInt64(1, m.Id)
	}

	if m.VmId != 0 {
		writer.WriteInt64(2, m.VmId)
	}

	if len(m.Source) > 0 {
		writer.WriteString(3, m.Source)
	}

	return
}

// Marshal marshals HIDRunningJobStateResult to a slice of bytes.
func (m *HIDRunningJobStateResult) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDRunningJobStateResult from the provided reader.
func (m *HIDRunningJobStateResult) UnmarshalFromReader(reader jspb.Reader) *HIDRunningJobStateResult {
	for reader.Next() {
		if m == nil {
			m = &HIDRunningJobStateResult{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Id = reader.ReadInt64()
		case 2:
			m.VmId = reader.ReadInt64()
		case 3:
			m.Source = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDRunningJobStateResult from a slice of bytes.
func (m *HIDRunningJobStateResult) Unmarshal(rawBytes []byte) (*HIDRunningJobStateResult, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HIDScriptResult struct {
	Job        *HIDScriptJob
	IsFinished bool
	ResultJson string
}

// GetJob gets the Job of the HIDScriptResult.
func (m *HIDScriptResult) GetJob() (x *HIDScriptJob) {
	if m == nil {
		return x
	}
	return m.Job
}

// GetIsFinished gets the IsFinished of the HIDScriptResult.
func (m *HIDScriptResult) GetIsFinished() (x bool) {
	if m == nil {
		return x
	}
	return m.IsFinished
}

// GetResultJson gets the ResultJson of the HIDScriptResult.
func (m *HIDScriptResult) GetResultJson() (x string) {
	if m == nil {
		return x
	}
	return m.ResultJson
}

// MarshalToWriter marshals HIDScriptResult to the provided writer.
func (m *HIDScriptResult) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Job != nil {
		writer.WriteMessage(1, func() {
			m.Job.MarshalToWriter(writer)
		})
	}

	if m.IsFinished {
		writer.WriteBool(2, m.IsFinished)
	}

	if len(m.ResultJson) > 0 {
		writer.WriteString(3, m.ResultJson)
	}

	return
}

// Marshal marshals HIDScriptResult to a slice of bytes.
func (m *HIDScriptResult) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDScriptResult from the provided reader.
func (m *HIDScriptResult) UnmarshalFromReader(reader jspb.Reader) *HIDScriptResult {
	for reader.Next() {
		if m == nil {
			m = &HIDScriptResult{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Job = m.Job.UnmarshalFromReader(reader)
			})
		case 2:
			m.IsFinished = reader.ReadBool()
		case 3:
			m.ResultJson = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDScriptResult from a slice of bytes.
func (m *HIDScriptResult) Unmarshal(rawBytes []byte) (*HIDScriptResult, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// LED
type LEDSettings struct {
	BlinkCount uint32
}

// GetBlinkCount gets the BlinkCount of the LEDSettings.
func (m *LEDSettings) GetBlinkCount() (x uint32) {
	if m == nil {
		return x
	}
	return m.BlinkCount
}

// MarshalToWriter marshals LEDSettings to the provided writer.
func (m *LEDSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.BlinkCount != 0 {
		writer.WriteUint32(1, m.BlinkCount)
	}

	return
}

// Marshal marshals LEDSettings to a slice of bytes.
func (m *LEDSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a LEDSettings from the provided reader.
func (m *LEDSettings) UnmarshalFromReader(reader jspb.Reader) *LEDSettings {
	for reader.Next() {
		if m == nil {
			m = &LEDSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.BlinkCount = reader.ReadUint32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a LEDSettings from a slice of bytes.
func (m *LEDSettings) Unmarshal(rawBytes []byte) (*LEDSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// USB Gadget
type GadgetSettings struct {
	Enabled          bool
	Vid              string
	Pid              string
	Manufacturer     string
	Product          string
	Serial           string
	Use_CDC_ECM      bool
	Use_RNDIS        bool
	Use_HID_KEYBOARD bool
	Use_HID_MOUSE    bool
	Use_HID_RAW      bool
	Use_UMS          bool
	Use_SERIAL       bool
	RndisSettings    *GadgetSettingsEthernet
	CdcEcmSettings   *GadgetSettingsEthernet
	UmsSettings      *GadgetSettingsUMS
}

// GetEnabled gets the Enabled of the GadgetSettings.
func (m *GadgetSettings) GetEnabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Enabled
}

// GetVid gets the Vid of the GadgetSettings.
func (m *GadgetSettings) GetVid() (x string) {
	if m == nil {
		return x
	}
	return m.Vid
}

// GetPid gets the Pid of the GadgetSettings.
func (m *GadgetSettings) GetPid() (x string) {
	if m == nil {
		return x
	}
	return m.Pid
}

// GetManufacturer gets the Manufacturer of the GadgetSettings.
func (m *GadgetSettings) GetManufacturer() (x string) {
	if m == nil {
		return x
	}
	return m.Manufacturer
}

// GetProduct gets the Product of the GadgetSettings.
func (m *GadgetSettings) GetProduct() (x string) {
	if m == nil {
		return x
	}
	return m.Product
}

// GetSerial gets the Serial of the GadgetSettings.
func (m *GadgetSettings) GetSerial() (x string) {
	if m == nil {
		return x
	}
	return m.Serial
}

// GetUse_CDC_ECM gets the Use_CDC_ECM of the GadgetSettings.
func (m *GadgetSettings) GetUse_CDC_ECM() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_CDC_ECM
}

// GetUse_RNDIS gets the Use_RNDIS of the GadgetSettings.
func (m *GadgetSettings) GetUse_RNDIS() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_RNDIS
}

// GetUse_HID_KEYBOARD gets the Use_HID_KEYBOARD of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_KEYBOARD() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_KEYBOARD
}

// GetUse_HID_MOUSE gets the Use_HID_MOUSE of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_MOUSE() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_MOUSE
}

// GetUse_HID_RAW gets the Use_HID_RAW of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_RAW() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_RAW
}

// GetUse_UMS gets the Use_UMS of the GadgetSettings.
func (m *GadgetSettings) GetUse_UMS() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_UMS
}

// GetUse_SERIAL gets the Use_SERIAL of the GadgetSettings.
func (m *GadgetSettings) GetUse_SERIAL() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_SERIAL
}

// GetRndisSettings gets the RndisSettings of the GadgetSettings.
func (m *GadgetSettings) GetRndisSettings() (x *GadgetSettingsEthernet) {
	if m == nil {
		return x
	}
	return m.RndisSettings
}

// GetCdcEcmSettings gets the CdcEcmSettings of the GadgetSettings.
func (m *GadgetSettings) GetCdcEcmSettings() (x *GadgetSettingsEthernet) {
	if m == nil {
		return x
	}
	return m.CdcEcmSettings
}

// GetUmsSettings gets the UmsSettings of the GadgetSettings.
func (m *GadgetSettings) GetUmsSettings() (x *GadgetSettingsUMS) {
	if m == nil {
		return x
	}
	return m.UmsSettings
}

// MarshalToWriter marshals GadgetSettings to the provided writer.
func (m *GadgetSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Enabled {
		writer.WriteBool(1, m.Enabled)
	}

	if len(m.Vid) > 0 {
		writer.WriteString(2, m.Vid)
	}

	if len(m.Pid) > 0 {
		writer.WriteString(3, m.Pid)
	}

	if len(m.Manufacturer) > 0 {
		writer.WriteString(4, m.Manufacturer)
	}

	if len(m.Product) > 0 {
		writer.WriteString(5, m.Product)
	}

	if len(m.Serial) > 0 {
		writer.WriteString(6, m.Serial)
	}

	if m.Use_CDC_ECM {
		writer.WriteBool(7, m.Use_CDC_ECM)
	}

	if m.Use_RNDIS {
		writer.WriteBool(8, m.Use_RNDIS)
	}

	if m.Use_HID_KEYBOARD {
		writer.WriteBool(9, m.Use_HID_KEYBOARD)
	}

	if m.Use_HID_MOUSE {
		writer.WriteBool(10, m.Use_HID_MOUSE)
	}

	if m.Use_HID_RAW {
		writer.WriteBool(11, m.Use_HID_RAW)
	}

	if m.Use_UMS {
		writer.WriteBool(12, m.Use_UMS)
	}

	if m.Use_SERIAL {
		writer.WriteBool(13, m.Use_SERIAL)
	}

	if m.RndisSettings != nil {
		writer.WriteMessage(14, func() {
			m.RndisSettings.MarshalToWriter(writer)
		})
	}

	if m.CdcEcmSettings != nil {
		writer.WriteMessage(15, func() {
			m.CdcEcmSettings.MarshalToWriter(writer)
		})
	}

	if m.UmsSettings != nil {
		writer.WriteMessage(16, func() {
			m.UmsSettings.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals GadgetSettings to a slice of bytes.
func (m *GadgetSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettings from the provided reader.
func (m *GadgetSettings) UnmarshalFromReader(reader jspb.Reader) *GadgetSettings {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Enabled = reader.ReadBool()
		case 2:
			m.Vid = reader.ReadString()
		case 3:
			m.Pid = reader.ReadString()
		case 4:
			m.Manufacturer = reader.ReadString()
		case 5:
			m.Product = reader.ReadString()
		case 6:
			m.Serial = reader.ReadString()
		case 7:
			m.Use_CDC_ECM = reader.ReadBool()
		case 8:
			m.Use_RNDIS = reader.ReadBool()
		case 9:
			m.Use_HID_KEYBOARD = reader.ReadBool()
		case 10:
			m.Use_HID_MOUSE = reader.ReadBool()
		case 11:
			m.Use_HID_RAW = reader.ReadBool()
		case 12:
			m.Use_UMS = reader.ReadBool()
		case 13:
			m.Use_SERIAL = reader.ReadBool()
		case 14:
			reader.ReadMessage(func() {
				m.RndisSettings = m.RndisSettings.UnmarshalFromReader(reader)
			})
		case 15:
			reader.ReadMessage(func() {
				m.CdcEcmSettings = m.CdcEcmSettings.UnmarshalFromReader(reader)
			})
		case 16:
			reader.ReadMessage(func() {
				m.UmsSettings = m.UmsSettings.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettings from a slice of bytes.
func (m *GadgetSettings) Unmarshal(rawBytes []byte) (*GadgetSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GadgetSettingsEthernet struct {
	HostAddr string
	DevAddr  string
}

// GetHostAddr gets the HostAddr of the GadgetSettingsEthernet.
func (m *GadgetSettingsEthernet) GetHostAddr() (x string) {
	if m == nil {
		return x
	}
	return m.HostAddr
}

// GetDevAddr gets the DevAddr of the GadgetSettingsEthernet.
func (m *GadgetSettingsEthernet) GetDevAddr() (x string) {
	if m == nil {
		return x
	}
	return m.DevAddr
}

// MarshalToWriter marshals GadgetSettingsEthernet to the provided writer.
func (m *GadgetSettingsEthernet) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.HostAddr) > 0 {
		writer.WriteString(1, m.HostAddr)
	}

	if len(m.DevAddr) > 0 {
		writer.WriteString(2, m.DevAddr)
	}

	return
}

// Marshal marshals GadgetSettingsEthernet to a slice of bytes.
func (m *GadgetSettingsEthernet) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettingsEthernet from the provided reader.
func (m *GadgetSettingsEthernet) UnmarshalFromReader(reader jspb.Reader) *GadgetSettingsEthernet {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettingsEthernet{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.HostAddr = reader.ReadString()
		case 2:
			m.DevAddr = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettingsEthernet from a slice of bytes.
func (m *GadgetSettingsEthernet) Unmarshal(rawBytes []byte) (*GadgetSettingsEthernet, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GadgetSettingsUMS struct {
	Cdrom bool
	File  string
}

// GetCdrom gets the Cdrom of the GadgetSettingsUMS.
func (m *GadgetSettingsUMS) GetCdrom() (x bool) {
	if m == nil {
		return x
	}
	return m.Cdrom
}

// GetFile gets the File of the GadgetSettingsUMS.
func (m *GadgetSettingsUMS) GetFile() (x string) {
	if m == nil {
		return x
	}
	return m.File
}

// MarshalToWriter marshals GadgetSettingsUMS to the provided writer.
func (m *GadgetSettingsUMS) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Cdrom {
		writer.WriteBool(1, m.Cdrom)
	}

	if len(m.File) > 0 {
		writer.WriteString(2, m.File)
	}

	return
}

// Marshal marshals GadgetSettingsUMS to a slice of bytes.
func (m *GadgetSettingsUMS) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettingsUMS from the provided reader.
func (m *GadgetSettingsUMS) UnmarshalFromReader(reader jspb.Reader) *GadgetSettingsUMS {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettingsUMS{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Cdrom = reader.ReadBool()
		case 2:
			m.File = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettingsUMS from a slice of bytes.
func (m *GadgetSettingsUMS) Unmarshal(rawBytes []byte) (*GadgetSettingsUMS, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Ethernet Interface Settings
type DeployedEthernetInterfaceSettings struct {
	List []*EthernetInterfaceSettings
}

// GetList gets the List of the DeployedEthernetInterfaceSettings.
func (m *DeployedEthernetInterfaceSettings) GetList() (x []*EthernetInterfaceSettings) {
	if m == nil {
		return x
	}
	return m.List
}

// MarshalToWriter marshals DeployedEthernetInterfaceSettings to the provided writer.
func (m *DeployedEthernetInterfaceSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	for _, msg := range m.List {
		writer.WriteMessage(1, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals DeployedEthernetInterfaceSettings to a slice of bytes.
func (m *DeployedEthernetInterfaceSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DeployedEthernetInterfaceSettings from the provided reader.
func (m *DeployedEthernetInterfaceSettings) UnmarshalFromReader(reader jspb.Reader) *DeployedEthernetInterfaceSettings {
	for reader.Next() {
		if m == nil {
			m = &DeployedEthernetInterfaceSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.List = append(m.List, new(EthernetInterfaceSettings).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DeployedEthernetInterfaceSettings from a slice of bytes.
func (m *DeployedEthernetInterfaceSettings) Unmarshal(rawBytes []byte) (*DeployedEthernetInterfaceSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EthernetInterfaceSettings struct {
	Name               string
	Mode               EthernetInterfaceSettings_Mode
	IpAddress4         string
	Netmask4           string
	Enabled            bool
	DhcpServerSettings *DHCPServerSettings
	SettingsInUse      bool
}

// GetName gets the Name of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetMode gets the Mode of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetMode() (x EthernetInterfaceSettings_Mode) {
	if m == nil {
		return x
	}
	return m.Mode
}

// GetIpAddress4 gets the IpAddress4 of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetIpAddress4() (x string) {
	if m == nil {
		return x
	}
	return m.IpAddress4
}

// GetNetmask4 gets the Netmask4 of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetNetmask4() (x string) {
	if m == nil {
		return x
	}
	return m.Netmask4
}

// GetEnabled gets the Enabled of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetEnabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Enabled
}

// GetDhcpServerSettings gets the DhcpServerSettings of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetDhcpServerSettings() (x *DHCPServerSettings) {
	if m == nil {
		return x
	}
	return m.DhcpServerSettings
}

// GetSettingsInUse gets the SettingsInUse of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetSettingsInUse() (x bool) {
	if m == nil {
		return x
	}
	return m.SettingsInUse
}

// MarshalToWriter marshals EthernetInterfaceSettings to the provided writer.
func (m *EthernetInterfaceSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Name) > 0 {
		writer.WriteString(1, m.Name)
	}

	if int(m.Mode) != 0 {
		writer.WriteEnum(2, int(m.Mode))
	}

	if len(m.IpAddress4) > 0 {
		writer.WriteString(3, m.IpAddress4)
	}

	if len(m.Netmask4) > 0 {
		writer.WriteString(4, m.Netmask4)
	}

	if m.Enabled {
		writer.WriteBool(5, m.Enabled)
	}

	if m.DhcpServerSettings != nil {
		writer.WriteMessage(6, func() {
			m.DhcpServerSettings.MarshalToWriter(writer)
		})
	}

	if m.SettingsInUse {
		writer.WriteBool(7, m.SettingsInUse)
	}

	return
}

// Marshal marshals EthernetInterfaceSettings to a slice of bytes.
func (m *EthernetInterfaceSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EthernetInterfaceSettings from the provided reader.
func (m *EthernetInterfaceSettings) UnmarshalFromReader(reader jspb.Reader) *EthernetInterfaceSettings {
	for reader.Next() {
		if m == nil {
			m = &EthernetInterfaceSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Name = reader.ReadString()
		case 2:
			m.Mode = EthernetInterfaceSettings_Mode(reader.ReadEnum())
		case 3:
			m.IpAddress4 = reader.ReadString()
		case 4:
			m.Netmask4 = reader.ReadString()
		case 5:
			m.Enabled = reader.ReadBool()
		case 6:
			reader.ReadMessage(func() {
				m.DhcpServerSettings = m.DhcpServerSettings.UnmarshalFromReader(reader)
			})
		case 7:
			m.SettingsInUse = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EthernetInterfaceSettings from a slice of bytes.
func (m *EthernetInterfaceSettings) Unmarshal(rawBytes []byte) (*EthernetInterfaceSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// DHCP
type DHCPServerSettings struct {
	ListenPort         uint32
	ListenInterface    string
	LeaseFile          string
	NotAuthoritative   bool
	DoNotBindInterface bool
	CallbackScript     string
	Ranges             []*DHCPServerRange
	// repeated DHCPServerOption options = 8;
	Options     map[uint32]string
	StaticHosts []*DHCPServerStaticHost
}

// GetListenPort gets the ListenPort of the DHCPServerSettings.
func (m *DHCPServerSettings) GetListenPort() (x uint32) {
	if m == nil {
		return x
	}
	return m.ListenPort
}

// GetListenInterface gets the ListenInterface of the DHCPServerSettings.
func (m *DHCPServerSettings) GetListenInterface() (x string) {
	if m == nil {
		return x
	}
	return m.ListenInterface
}

// GetLeaseFile gets the LeaseFile of the DHCPServerSettings.
func (m *DHCPServerSettings) GetLeaseFile() (x string) {
	if m == nil {
		return x
	}
	return m.LeaseFile
}

// GetNotAuthoritative gets the NotAuthoritative of the DHCPServerSettings.
func (m *DHCPServerSettings) GetNotAuthoritative() (x bool) {
	if m == nil {
		return x
	}
	return m.NotAuthoritative
}

// GetDoNotBindInterface gets the DoNotBindInterface of the DHCPServerSettings.
func (m *DHCPServerSettings) GetDoNotBindInterface() (x bool) {
	if m == nil {
		return x
	}
	return m.DoNotBindInterface
}

// GetCallbackScript gets the CallbackScript of the DHCPServerSettings.
func (m *DHCPServerSettings) GetCallbackScript() (x string) {
	if m == nil {
		return x
	}
	return m.CallbackScript
}

// GetRanges gets the Ranges of the DHCPServerSettings.
func (m *DHCPServerSettings) GetRanges() (x []*DHCPServerRange) {
	if m == nil {
		return x
	}
	return m.Ranges
}

// GetOptions gets the Options of the DHCPServerSettings.
func (m *DHCPServerSettings) GetOptions() (x map[uint32]string) {
	if m == nil {
		return x
	}
	return m.Options
}

// GetStaticHosts gets the StaticHosts of the DHCPServerSettings.
func (m *DHCPServerSettings) GetStaticHosts() (x []*DHCPServerStaticHost) {
	if m == nil {
		return x
	}
	return m.StaticHosts
}

// MarshalToWriter marshals DHCPServerSettings to the provided writer.
func (m *DHCPServerSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ListenPort != 0 {
		writer.WriteUint32(1, m.ListenPort)
	}

	if len(m.ListenInterface) > 0 {
		writer.WriteString(2, m.ListenInterface)
	}

	if len(m.LeaseFile) > 0 {
		writer.WriteString(3, m.LeaseFile)
	}

	if m.NotAuthoritative {
		writer.WriteBool(4, m.NotAuthoritative)
	}

	if m.DoNotBindInterface {
		writer.WriteBool(5, m.DoNotBindInterface)
	}

	if len(m.CallbackScript) > 0 {
		writer.WriteString(6, m.CallbackScript)
	}

	for _, msg := range m.Ranges {
		writer.WriteMessage(7, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if len(m.Options) > 0 {
		for key, value := range m.Options {
			writer.WriteMessage(8, func() {
				writer.WriteUint32(1, key)
				writer.WriteString(2, value)
			})
		}
	}

	for _, msg := range m.StaticHosts {
		writer.WriteMessage(9, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals DHCPServerSettings to a slice of bytes.
func (m *DHCPServerSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerSettings from the provided reader.
func (m *DHCPServerSettings) UnmarshalFromReader(reader jspb.Reader) *DHCPServerSettings {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ListenPort = reader.ReadUint32()
		case 2:
			m.ListenInterface = reader.ReadString()
		case 3:
			m.LeaseFile = reader.ReadString()
		case 4:
			m.NotAuthoritative = reader.ReadBool()
		case 5:
			m.DoNotBindInterface = reader.ReadBool()
		case 6:
			m.CallbackScript = reader.ReadString()
		case 7:
			reader.ReadMessage(func() {
				m.Ranges = append(m.Ranges, new(DHCPServerRange).UnmarshalFromReader(reader))
			})
		case 8:
			if m.Options == nil {
				m.Options = map[uint32]string{}
			}
			reader.ReadMessage(func() {
				var key uint32
				var value string
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadUint32()
					case 2:
						value = reader.ReadString()
					}
					m.Options[key] = value
				}
			})
		case 9:
			reader.ReadMessage(func() {
				m.StaticHosts = append(m.StaticHosts, new(DHCPServerStaticHost).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerSettings from a slice of bytes.
func (m *DHCPServerSettings) Unmarshal(rawBytes []byte) (*DHCPServerSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Could be used for IPv4 or IPv6 (refer dnsmasq docs), nor field for prefix length (default is 64)
type DHCPServerRange struct {
	RangeLower string
	RangeUpper string
	LeaseTime  string
}

// GetRangeLower gets the RangeLower of the DHCPServerRange.
func (m *DHCPServerRange) GetRangeLower() (x string) {
	if m == nil {
		return x
	}
	return m.RangeLower
}

// GetRangeUpper gets the RangeUpper of the DHCPServerRange.
func (m *DHCPServerRange) GetRangeUpper() (x string) {
	if m == nil {
		return x
	}
	return m.RangeUpper
}

// GetLeaseTime gets the LeaseTime of the DHCPServerRange.
func (m *DHCPServerRange) GetLeaseTime() (x string) {
	if m == nil {
		return x
	}
	return m.LeaseTime
}

// MarshalToWriter marshals DHCPServerRange to the provided writer.
func (m *DHCPServerRange) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.RangeLower) > 0 {
		writer.WriteString(1, m.RangeLower)
	}

	if len(m.RangeUpper) > 0 {
		writer.WriteString(2, m.RangeUpper)
	}

	if len(m.LeaseTime) > 0 {
		writer.WriteString(3, m.LeaseTime)
	}

	return
}

// Marshal marshals DHCPServerRange to a slice of bytes.
func (m *DHCPServerRange) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerRange from the provided reader.
func (m *DHCPServerRange) UnmarshalFromReader(reader jspb.Reader) *DHCPServerRange {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerRange{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.RangeLower = reader.ReadString()
		case 2:
			m.RangeUpper = reader.ReadString()
		case 3:
			m.LeaseTime = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerRange from a slice of bytes.
func (m *DHCPServerRange) Unmarshal(rawBytes []byte) (*DHCPServerRange, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Used for static leases
type DHCPServerStaticHost struct {
	Mac string
	Ip  string
}

// GetMac gets the Mac of the DHCPServerStaticHost.
func (m *DHCPServerStaticHost) GetMac() (x string) {
	if m == nil {
		return x
	}
	return m.Mac
}

// GetIp gets the Ip of the DHCPServerStaticHost.
func (m *DHCPServerStaticHost) GetIp() (x string) {
	if m == nil {
		return x
	}
	return m.Ip
}

// MarshalToWriter marshals DHCPServerStaticHost to the provided writer.
func (m *DHCPServerStaticHost) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Mac) > 0 {
		writer.WriteString(1, m.Mac)
	}

	if len(m.Ip) > 0 {
		writer.WriteString(2, m.Ip)
	}

	return
}

// Marshal marshals DHCPServerStaticHost to a slice of bytes.
func (m *DHCPServerStaticHost) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerStaticHost from the provided reader.
func (m *DHCPServerStaticHost) UnmarshalFromReader(reader jspb.Reader) *DHCPServerStaticHost {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerStaticHost{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Mac = reader.ReadString()
		case 2:
			m.Ip = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerStaticHost from a slice of bytes.
func (m *DHCPServerStaticHost) Unmarshal(rawBytes []byte) (*DHCPServerStaticHost, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Empty struct {
}

// MarshalToWriter marshals Empty to the provided writer.
func (m *Empty) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	return
}

// Marshal marshals Empty to a slice of bytes.
func (m *Empty) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Empty from the provided reader.
func (m *Empty) UnmarshalFromReader(reader jspb.Reader) *Empty {
	for reader.Next() {
		if m == nil {
			m = &Empty{}
		}

		switch reader.GetFieldNumber() {
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Empty from a slice of bytes.
func (m *Empty) Unmarshal(rawBytes []byte) (*Empty, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for P4WNP1 service

type P4WNP1Client interface {
	// USB gadget
	GetDeployedGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	DeployGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	GetGadgetSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	SetGadgetSettings(ctx context.Context, in *GadgetSettings, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	GetLEDSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*LEDSettings, error)
	SetLEDSettings(ctx context.Context, in *LEDSettings, opts ...grpcweb.CallOption) (*Empty, error)
	MountUMSFile(ctx context.Context, in *GadgetSettingsUMS, opts ...grpcweb.CallOption) (*Empty, error)
	// Ethernet
	DeployEthernetInterfaceSettings(ctx context.Context, in *EthernetInterfaceSettings, opts ...grpcweb.CallOption) (*Empty, error)
	GetAllDeployedEthernetInterfaceSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*DeployedEthernetInterfaceSettings, error)
	GetDeployedEthernetInterfaceSettings(ctx context.Context, in *StringMessage, opts ...grpcweb.CallOption) (*EthernetInterfaceSettings, error)
	// HIDScript / job management
	HIDRunScript(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptResult, error)
	HIDRunScriptJob(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptJob, error)
	HIDGetScriptJobResult(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*HIDScriptResult, error)
	HIDCancelScriptJob(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*Empty, error)
	HIDGetRunningScriptJobs(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*HIDScriptJobList, error)
	HIDCancelAllScriptJobs(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*Empty, error)
	HIDGetRunningJobState(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*HIDRunningJobStateResult, error)
	// FileSystem
	FSWriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpcweb.CallOption) (*Empty, error)
	FSReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpcweb.CallOption) (*ReadFileResponse, error)
	FSGetFileInfo(ctx context.Context, in *FileInfoRequest, opts ...grpcweb.CallOption) (*FileInfoResponse, error)
	FSCreateTempDirOrFile(ctx context.Context, in *TempDirOrFileRequest, opts ...grpcweb.CallOption) (*TempDirOrFileResponse, error)
	// Events
	EventListen(ctx context.Context, in *EventRequest, opts ...grpcweb.CallOption) (P4WNP1_EventListenClient, error)
	// Alive check
	EchoRequest(ctx context.Context, in *StringMessage, opts ...grpcweb.CallOption) (*StringMessage, error)
	// WiFi
	DeployWiFiSettings(ctx context.Context, in *WiFiSettings, opts ...grpcweb.CallOption) (*WiFiState, error)
	GetWiFiState(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*WiFiState, error)
	ListenWiFiStateChanges(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*WiFiState, error)
}

type p4WNP1Client struct {
	client *grpcweb.Client
}

// NewP4WNP1Client creates a new gRPC-Web client.
func NewP4WNP1Client(hostname string, opts ...grpcweb.DialOption) P4WNP1Client {
	return &p4WNP1Client{
		client: grpcweb.NewClient(hostname, "P4wnP1_grpc.P4WNP1", opts...),
	}
}

func (c *p4WNP1Client) GetDeployedGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetDeployedGadgetSetting", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "DeployGadgetSetting", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) GetGadgetSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetGadgetSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) SetGadgetSettings(ctx context.Context, in *GadgetSettings, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "SetGadgetSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) GetLEDSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*LEDSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetLEDSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(LEDSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) SetLEDSettings(ctx context.Context, in *LEDSettings, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "SetLEDSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) MountUMSFile(ctx context.Context, in *GadgetSettingsUMS, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "MountUMSFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployEthernetInterfaceSettings(ctx context.Context, in *EthernetInterfaceSettings, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "DeployEthernetInterfaceSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) GetAllDeployedEthernetInterfaceSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*DeployedEthernetInterfaceSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetAllDeployedEthernetInterfaceSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(DeployedEthernetInterfaceSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) GetDeployedEthernetInterfaceSettings(ctx context.Context, in *StringMessage, opts ...grpcweb.CallOption) (*EthernetInterfaceSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetDeployedEthernetInterfaceSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(EthernetInterfaceSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDRunScript(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptResult, error) {
	resp, err := c.client.RPCCall(ctx, "HIDRunScript", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDScriptResult).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDRunScriptJob(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptJob, error) {
	resp, err := c.client.RPCCall(ctx, "HIDRunScriptJob", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDScriptJob).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDGetScriptJobResult(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*HIDScriptResult, error) {
	resp, err := c.client.RPCCall(ctx, "HIDGetScriptJobResult", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDScriptResult).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDCancelScriptJob(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "HIDCancelScriptJob", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDGetRunningScriptJobs(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*HIDScriptJobList, error) {
	resp, err := c.client.RPCCall(ctx, "HIDGetRunningScriptJobs", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDScriptJobList).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDCancelAllScriptJobs(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "HIDCancelAllScriptJobs", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDGetRunningJobState(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*HIDRunningJobStateResult, error) {
	resp, err := c.client.RPCCall(ctx, "HIDGetRunningJobState", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDRunningJobStateResult).Unmarshal(resp)
}

func (c *p4WNP1Client) FSWriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "FSWriteFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) FSReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpcweb.CallOption) (*ReadFileResponse, error) {
	resp, err := c.client.RPCCall(ctx, "FSReadFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ReadFileResponse).Unmarshal(resp)
}

func (c *p4WNP1Client) FSGetFileInfo(ctx context.Context, in *FileInfoRequest, opts ...grpcweb.CallOption) (*FileInfoResponse, error) {
	resp, err := c.client.RPCCall(ctx, "FSGetFileInfo", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(FileInfoResponse).Unmarshal(resp)
}

func (c *p4WNP1Client) FSCreateTempDirOrFile(ctx context.Context, in *TempDirOrFileRequest, opts ...grpcweb.CallOption) (*TempDirOrFileResponse, error) {
	resp, err := c.client.RPCCall(ctx, "FSCreateTempDirOrFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(TempDirOrFileResponse).Unmarshal(resp)
}

func (c *p4WNP1Client) EventListen(ctx context.Context, in *EventRequest, opts ...grpcweb.CallOption) (P4WNP1_EventListenClient, error) {
	srv, err := c.client.NewClientStream(ctx, false, true, "EventListen", opts...)
	if err != nil {
		return nil, err
	}

	err = srv.SendMsg(in.Marshal())
	if err != nil {
		return nil, err
	}

	return &p4WNP1EventListenClient{srv}, nil
}

type P4WNP1_EventListenClient interface {
	Recv() (*Event, error)
	grpcweb.ClientStream
}

type p4WNP1EventListenClient struct {
	grpcweb.ClientStream
}

func (x *p4WNP1EventListenClient) Recv() (*Event, error) {
	resp, err := x.RecvMsg()
	if err != nil {
		return nil, err
	}

	return new(Event).Unmarshal(resp)
}

func (c *p4WNP1Client) EchoRequest(ctx context.Context, in *StringMessage, opts ...grpcweb.CallOption) (*StringMessage, error) {
	resp, err := c.client.RPCCall(ctx, "EchoRequest", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(StringMessage).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployWiFiSettings(ctx context.Context, in *WiFiSettings, opts ...grpcweb.CallOption) (*WiFiState, error) {
	resp, err := c.client.RPCCall(ctx, "DeployWiFiSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(WiFiState).Unmarshal(resp)
}

func (c *p4WNP1Client) GetWiFiState(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*WiFiState, error) {
	resp, err := c.client.RPCCall(ctx, "GetWiFiState", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(WiFiState).Unmarshal(resp)
}

func (c *p4WNP1Client) ListenWiFiStateChanges(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*WiFiState, error) {
	resp, err := c.client.RPCCall(ctx, "ListenWiFiStateChanges", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(WiFiState).Unmarshal(resp)
}
