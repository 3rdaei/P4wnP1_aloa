// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: grpc.proto

/*
	Package P4wnP1_grpc is a generated protocol buffer package.

	It is generated from these files:
		grpc.proto

	It has these top-level messages:
		LEDSettings
		GadgetSettings
		GadgetSettingsEthernet
		GadgetSettingsUMS
		EthernetInterfaceSettings
		DHCPServerSettings
		DHCPServerRange
		DHCPServerStaticHost
		WiFiSettings
		Empty
*/
package P4wnP1_grpc

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type EthernetInterfaceSettings_Mode int

const (
	EthernetInterfaceSettings_MANUAL      EthernetInterfaceSettings_Mode = 0
	EthernetInterfaceSettings_DHCP_CLIENT EthernetInterfaceSettings_Mode = 1
	EthernetInterfaceSettings_DHCP_SERVER EthernetInterfaceSettings_Mode = 2
)

var EthernetInterfaceSettings_Mode_name = map[int]string{
	0: "MANUAL",
	1: "DHCP_CLIENT",
	2: "DHCP_SERVER",
}
var EthernetInterfaceSettings_Mode_value = map[string]int{
	"MANUAL":      0,
	"DHCP_CLIENT": 1,
	"DHCP_SERVER": 2,
}

func (x EthernetInterfaceSettings_Mode) String() string {
	return EthernetInterfaceSettings_Mode_name[int(x)]
}

type WiFiSettings_Mode int

const (
	WiFiSettings_AP              WiFiSettings_Mode = 0
	WiFiSettings_STA             WiFiSettings_Mode = 1
	WiFiSettings_STA_FAILOVER_AP WiFiSettings_Mode = 2
)

var WiFiSettings_Mode_name = map[int]string{
	0: "AP",
	1: "STA",
	2: "STA_FAILOVER_AP",
}
var WiFiSettings_Mode_value = map[string]int{
	"AP":              0,
	"STA":             1,
	"STA_FAILOVER_AP": 2,
}

func (x WiFiSettings_Mode) String() string {
	return WiFiSettings_Mode_name[int(x)]
}

type WiFiSettings_APAuthMode int

const (
	WiFiSettings_WPA2_PSK WiFiSettings_APAuthMode = 0
	WiFiSettings_OPEN     WiFiSettings_APAuthMode = 1
)

var WiFiSettings_APAuthMode_name = map[int]string{
	0: "WPA2_PSK",
	1: "OPEN",
}
var WiFiSettings_APAuthMode_value = map[string]int{
	"WPA2_PSK": 0,
	"OPEN":     1,
}

func (x WiFiSettings_APAuthMode) String() string {
	return WiFiSettings_APAuthMode_name[int(x)]
}

// LED
type LEDSettings struct {
	BlinkCount uint32
}

// GetBlinkCount gets the BlinkCount of the LEDSettings.
func (m *LEDSettings) GetBlinkCount() (x uint32) {
	if m == nil {
		return x
	}
	return m.BlinkCount
}

// MarshalToWriter marshals LEDSettings to the provided writer.
func (m *LEDSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.BlinkCount != 0 {
		writer.WriteUint32(1, m.BlinkCount)
	}

	return
}

// Marshal marshals LEDSettings to a slice of bytes.
func (m *LEDSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a LEDSettings from the provided reader.
func (m *LEDSettings) UnmarshalFromReader(reader jspb.Reader) *LEDSettings {
	for reader.Next() {
		if m == nil {
			m = &LEDSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.BlinkCount = reader.ReadUint32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a LEDSettings from a slice of bytes.
func (m *LEDSettings) Unmarshal(rawBytes []byte) (*LEDSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// USB Gadget
type GadgetSettings struct {
	Enabled          bool
	Vid              string
	Pid              string
	Manufacturer     string
	Product          string
	Serial           string
	Use_CDC_ECM      bool
	Use_RNDIS        bool
	Use_HID_KEYBOARD bool
	Use_HID_MOUSE    bool
	Use_HID_RAW      bool
	Use_UMS          bool
	Use_SERIAL       bool
	RndisSettings    *GadgetSettingsEthernet
	CdcEcmSettings   *GadgetSettingsEthernet
	UmsSettings      *GadgetSettingsUMS
}

// GetEnabled gets the Enabled of the GadgetSettings.
func (m *GadgetSettings) GetEnabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Enabled
}

// GetVid gets the Vid of the GadgetSettings.
func (m *GadgetSettings) GetVid() (x string) {
	if m == nil {
		return x
	}
	return m.Vid
}

// GetPid gets the Pid of the GadgetSettings.
func (m *GadgetSettings) GetPid() (x string) {
	if m == nil {
		return x
	}
	return m.Pid
}

// GetManufacturer gets the Manufacturer of the GadgetSettings.
func (m *GadgetSettings) GetManufacturer() (x string) {
	if m == nil {
		return x
	}
	return m.Manufacturer
}

// GetProduct gets the Product of the GadgetSettings.
func (m *GadgetSettings) GetProduct() (x string) {
	if m == nil {
		return x
	}
	return m.Product
}

// GetSerial gets the Serial of the GadgetSettings.
func (m *GadgetSettings) GetSerial() (x string) {
	if m == nil {
		return x
	}
	return m.Serial
}

// GetUse_CDC_ECM gets the Use_CDC_ECM of the GadgetSettings.
func (m *GadgetSettings) GetUse_CDC_ECM() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_CDC_ECM
}

// GetUse_RNDIS gets the Use_RNDIS of the GadgetSettings.
func (m *GadgetSettings) GetUse_RNDIS() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_RNDIS
}

// GetUse_HID_KEYBOARD gets the Use_HID_KEYBOARD of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_KEYBOARD() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_KEYBOARD
}

// GetUse_HID_MOUSE gets the Use_HID_MOUSE of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_MOUSE() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_MOUSE
}

// GetUse_HID_RAW gets the Use_HID_RAW of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_RAW() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_RAW
}

// GetUse_UMS gets the Use_UMS of the GadgetSettings.
func (m *GadgetSettings) GetUse_UMS() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_UMS
}

// GetUse_SERIAL gets the Use_SERIAL of the GadgetSettings.
func (m *GadgetSettings) GetUse_SERIAL() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_SERIAL
}

// GetRndisSettings gets the RndisSettings of the GadgetSettings.
func (m *GadgetSettings) GetRndisSettings() (x *GadgetSettingsEthernet) {
	if m == nil {
		return x
	}
	return m.RndisSettings
}

// GetCdcEcmSettings gets the CdcEcmSettings of the GadgetSettings.
func (m *GadgetSettings) GetCdcEcmSettings() (x *GadgetSettingsEthernet) {
	if m == nil {
		return x
	}
	return m.CdcEcmSettings
}

// GetUmsSettings gets the UmsSettings of the GadgetSettings.
func (m *GadgetSettings) GetUmsSettings() (x *GadgetSettingsUMS) {
	if m == nil {
		return x
	}
	return m.UmsSettings
}

// MarshalToWriter marshals GadgetSettings to the provided writer.
func (m *GadgetSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Enabled {
		writer.WriteBool(1, m.Enabled)
	}

	if len(m.Vid) > 0 {
		writer.WriteString(2, m.Vid)
	}

	if len(m.Pid) > 0 {
		writer.WriteString(3, m.Pid)
	}

	if len(m.Manufacturer) > 0 {
		writer.WriteString(4, m.Manufacturer)
	}

	if len(m.Product) > 0 {
		writer.WriteString(5, m.Product)
	}

	if len(m.Serial) > 0 {
		writer.WriteString(6, m.Serial)
	}

	if m.Use_CDC_ECM {
		writer.WriteBool(7, m.Use_CDC_ECM)
	}

	if m.Use_RNDIS {
		writer.WriteBool(8, m.Use_RNDIS)
	}

	if m.Use_HID_KEYBOARD {
		writer.WriteBool(9, m.Use_HID_KEYBOARD)
	}

	if m.Use_HID_MOUSE {
		writer.WriteBool(10, m.Use_HID_MOUSE)
	}

	if m.Use_HID_RAW {
		writer.WriteBool(11, m.Use_HID_RAW)
	}

	if m.Use_UMS {
		writer.WriteBool(12, m.Use_UMS)
	}

	if m.Use_SERIAL {
		writer.WriteBool(13, m.Use_SERIAL)
	}

	if m.RndisSettings != nil {
		writer.WriteMessage(14, func() {
			m.RndisSettings.MarshalToWriter(writer)
		})
	}

	if m.CdcEcmSettings != nil {
		writer.WriteMessage(15, func() {
			m.CdcEcmSettings.MarshalToWriter(writer)
		})
	}

	if m.UmsSettings != nil {
		writer.WriteMessage(16, func() {
			m.UmsSettings.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals GadgetSettings to a slice of bytes.
func (m *GadgetSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettings from the provided reader.
func (m *GadgetSettings) UnmarshalFromReader(reader jspb.Reader) *GadgetSettings {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Enabled = reader.ReadBool()
		case 2:
			m.Vid = reader.ReadString()
		case 3:
			m.Pid = reader.ReadString()
		case 4:
			m.Manufacturer = reader.ReadString()
		case 5:
			m.Product = reader.ReadString()
		case 6:
			m.Serial = reader.ReadString()
		case 7:
			m.Use_CDC_ECM = reader.ReadBool()
		case 8:
			m.Use_RNDIS = reader.ReadBool()
		case 9:
			m.Use_HID_KEYBOARD = reader.ReadBool()
		case 10:
			m.Use_HID_MOUSE = reader.ReadBool()
		case 11:
			m.Use_HID_RAW = reader.ReadBool()
		case 12:
			m.Use_UMS = reader.ReadBool()
		case 13:
			m.Use_SERIAL = reader.ReadBool()
		case 14:
			reader.ReadMessage(func() {
				m.RndisSettings = m.RndisSettings.UnmarshalFromReader(reader)
			})
		case 15:
			reader.ReadMessage(func() {
				m.CdcEcmSettings = m.CdcEcmSettings.UnmarshalFromReader(reader)
			})
		case 16:
			reader.ReadMessage(func() {
				m.UmsSettings = m.UmsSettings.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettings from a slice of bytes.
func (m *GadgetSettings) Unmarshal(rawBytes []byte) (*GadgetSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GadgetSettingsEthernet struct {
	HostAddr string
	DevAddr  string
}

// GetHostAddr gets the HostAddr of the GadgetSettingsEthernet.
func (m *GadgetSettingsEthernet) GetHostAddr() (x string) {
	if m == nil {
		return x
	}
	return m.HostAddr
}

// GetDevAddr gets the DevAddr of the GadgetSettingsEthernet.
func (m *GadgetSettingsEthernet) GetDevAddr() (x string) {
	if m == nil {
		return x
	}
	return m.DevAddr
}

// MarshalToWriter marshals GadgetSettingsEthernet to the provided writer.
func (m *GadgetSettingsEthernet) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.HostAddr) > 0 {
		writer.WriteString(1, m.HostAddr)
	}

	if len(m.DevAddr) > 0 {
		writer.WriteString(2, m.DevAddr)
	}

	return
}

// Marshal marshals GadgetSettingsEthernet to a slice of bytes.
func (m *GadgetSettingsEthernet) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettingsEthernet from the provided reader.
func (m *GadgetSettingsEthernet) UnmarshalFromReader(reader jspb.Reader) *GadgetSettingsEthernet {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettingsEthernet{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.HostAddr = reader.ReadString()
		case 2:
			m.DevAddr = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettingsEthernet from a slice of bytes.
func (m *GadgetSettingsEthernet) Unmarshal(rawBytes []byte) (*GadgetSettingsEthernet, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GadgetSettingsUMS struct {
	Cdrom bool
	File  string
}

// GetCdrom gets the Cdrom of the GadgetSettingsUMS.
func (m *GadgetSettingsUMS) GetCdrom() (x bool) {
	if m == nil {
		return x
	}
	return m.Cdrom
}

// GetFile gets the File of the GadgetSettingsUMS.
func (m *GadgetSettingsUMS) GetFile() (x string) {
	if m == nil {
		return x
	}
	return m.File
}

// MarshalToWriter marshals GadgetSettingsUMS to the provided writer.
func (m *GadgetSettingsUMS) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Cdrom {
		writer.WriteBool(1, m.Cdrom)
	}

	if len(m.File) > 0 {
		writer.WriteString(2, m.File)
	}

	return
}

// Marshal marshals GadgetSettingsUMS to a slice of bytes.
func (m *GadgetSettingsUMS) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettingsUMS from the provided reader.
func (m *GadgetSettingsUMS) UnmarshalFromReader(reader jspb.Reader) *GadgetSettingsUMS {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettingsUMS{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Cdrom = reader.ReadBool()
		case 2:
			m.File = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettingsUMS from a slice of bytes.
func (m *GadgetSettingsUMS) Unmarshal(rawBytes []byte) (*GadgetSettingsUMS, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EthernetInterfaceSettings struct {
	Name               string
	Mode               EthernetInterfaceSettings_Mode
	IpAddress4         string
	Netmask4           string
	Enabled            bool
	DhcpServerSettings *DHCPServerSettings
}

// GetName gets the Name of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetMode gets the Mode of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetMode() (x EthernetInterfaceSettings_Mode) {
	if m == nil {
		return x
	}
	return m.Mode
}

// GetIpAddress4 gets the IpAddress4 of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetIpAddress4() (x string) {
	if m == nil {
		return x
	}
	return m.IpAddress4
}

// GetNetmask4 gets the Netmask4 of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetNetmask4() (x string) {
	if m == nil {
		return x
	}
	return m.Netmask4
}

// GetEnabled gets the Enabled of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetEnabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Enabled
}

// GetDhcpServerSettings gets the DhcpServerSettings of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetDhcpServerSettings() (x *DHCPServerSettings) {
	if m == nil {
		return x
	}
	return m.DhcpServerSettings
}

// MarshalToWriter marshals EthernetInterfaceSettings to the provided writer.
func (m *EthernetInterfaceSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Name) > 0 {
		writer.WriteString(1, m.Name)
	}

	if int(m.Mode) != 0 {
		writer.WriteEnum(2, int(m.Mode))
	}

	if len(m.IpAddress4) > 0 {
		writer.WriteString(3, m.IpAddress4)
	}

	if len(m.Netmask4) > 0 {
		writer.WriteString(4, m.Netmask4)
	}

	if m.Enabled {
		writer.WriteBool(5, m.Enabled)
	}

	if m.DhcpServerSettings != nil {
		writer.WriteMessage(6, func() {
			m.DhcpServerSettings.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals EthernetInterfaceSettings to a slice of bytes.
func (m *EthernetInterfaceSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EthernetInterfaceSettings from the provided reader.
func (m *EthernetInterfaceSettings) UnmarshalFromReader(reader jspb.Reader) *EthernetInterfaceSettings {
	for reader.Next() {
		if m == nil {
			m = &EthernetInterfaceSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Name = reader.ReadString()
		case 2:
			m.Mode = EthernetInterfaceSettings_Mode(reader.ReadEnum())
		case 3:
			m.IpAddress4 = reader.ReadString()
		case 4:
			m.Netmask4 = reader.ReadString()
		case 5:
			m.Enabled = reader.ReadBool()
		case 6:
			reader.ReadMessage(func() {
				m.DhcpServerSettings = m.DhcpServerSettings.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EthernetInterfaceSettings from a slice of bytes.
func (m *EthernetInterfaceSettings) Unmarshal(rawBytes []byte) (*EthernetInterfaceSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// DHCP
type DHCPServerSettings struct {
	ListenPort         uint32
	ListenInterface    string
	LeaseFile          string
	NotAuthoritative   bool
	DoNotBindInterface bool
	CallbackScript     string
	Ranges             []*DHCPServerRange
	// repeated DHCPServerOption options = 8;
	Options     map[uint32]string
	StaticHosts []*DHCPServerStaticHost
}

// GetListenPort gets the ListenPort of the DHCPServerSettings.
func (m *DHCPServerSettings) GetListenPort() (x uint32) {
	if m == nil {
		return x
	}
	return m.ListenPort
}

// GetListenInterface gets the ListenInterface of the DHCPServerSettings.
func (m *DHCPServerSettings) GetListenInterface() (x string) {
	if m == nil {
		return x
	}
	return m.ListenInterface
}

// GetLeaseFile gets the LeaseFile of the DHCPServerSettings.
func (m *DHCPServerSettings) GetLeaseFile() (x string) {
	if m == nil {
		return x
	}
	return m.LeaseFile
}

// GetNotAuthoritative gets the NotAuthoritative of the DHCPServerSettings.
func (m *DHCPServerSettings) GetNotAuthoritative() (x bool) {
	if m == nil {
		return x
	}
	return m.NotAuthoritative
}

// GetDoNotBindInterface gets the DoNotBindInterface of the DHCPServerSettings.
func (m *DHCPServerSettings) GetDoNotBindInterface() (x bool) {
	if m == nil {
		return x
	}
	return m.DoNotBindInterface
}

// GetCallbackScript gets the CallbackScript of the DHCPServerSettings.
func (m *DHCPServerSettings) GetCallbackScript() (x string) {
	if m == nil {
		return x
	}
	return m.CallbackScript
}

// GetRanges gets the Ranges of the DHCPServerSettings.
func (m *DHCPServerSettings) GetRanges() (x []*DHCPServerRange) {
	if m == nil {
		return x
	}
	return m.Ranges
}

// GetOptions gets the Options of the DHCPServerSettings.
func (m *DHCPServerSettings) GetOptions() (x map[uint32]string) {
	if m == nil {
		return x
	}
	return m.Options
}

// GetStaticHosts gets the StaticHosts of the DHCPServerSettings.
func (m *DHCPServerSettings) GetStaticHosts() (x []*DHCPServerStaticHost) {
	if m == nil {
		return x
	}
	return m.StaticHosts
}

// MarshalToWriter marshals DHCPServerSettings to the provided writer.
func (m *DHCPServerSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ListenPort != 0 {
		writer.WriteUint32(1, m.ListenPort)
	}

	if len(m.ListenInterface) > 0 {
		writer.WriteString(2, m.ListenInterface)
	}

	if len(m.LeaseFile) > 0 {
		writer.WriteString(3, m.LeaseFile)
	}

	if m.NotAuthoritative {
		writer.WriteBool(4, m.NotAuthoritative)
	}

	if m.DoNotBindInterface {
		writer.WriteBool(5, m.DoNotBindInterface)
	}

	if len(m.CallbackScript) > 0 {
		writer.WriteString(6, m.CallbackScript)
	}

	for _, msg := range m.Ranges {
		writer.WriteMessage(7, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if len(m.Options) > 0 {
		for key, value := range m.Options {
			writer.WriteMessage(8, func() {
				writer.WriteUint32(1, key)
				writer.WriteString(2, value)
			})
		}
	}

	for _, msg := range m.StaticHosts {
		writer.WriteMessage(9, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals DHCPServerSettings to a slice of bytes.
func (m *DHCPServerSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerSettings from the provided reader.
func (m *DHCPServerSettings) UnmarshalFromReader(reader jspb.Reader) *DHCPServerSettings {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ListenPort = reader.ReadUint32()
		case 2:
			m.ListenInterface = reader.ReadString()
		case 3:
			m.LeaseFile = reader.ReadString()
		case 4:
			m.NotAuthoritative = reader.ReadBool()
		case 5:
			m.DoNotBindInterface = reader.ReadBool()
		case 6:
			m.CallbackScript = reader.ReadString()
		case 7:
			reader.ReadMessage(func() {
				m.Ranges = append(m.Ranges, new(DHCPServerRange).UnmarshalFromReader(reader))
			})
		case 8:
			if m.Options == nil {
				m.Options = map[uint32]string{}
			}
			reader.ReadMessage(func() {
				var key uint32
				var value string
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadUint32()
					case 2:
						value = reader.ReadString()
					}
					m.Options[key] = value
				}
			})
		case 9:
			reader.ReadMessage(func() {
				m.StaticHosts = append(m.StaticHosts, new(DHCPServerStaticHost).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerSettings from a slice of bytes.
func (m *DHCPServerSettings) Unmarshal(rawBytes []byte) (*DHCPServerSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Could be used for IPv4 or IPv6 (refer dnsmasq docs), nor field for prefix length (default is 64)
type DHCPServerRange struct {
	RangeLower string
	RangeUpper string
	LeaseTime  string
}

// GetRangeLower gets the RangeLower of the DHCPServerRange.
func (m *DHCPServerRange) GetRangeLower() (x string) {
	if m == nil {
		return x
	}
	return m.RangeLower
}

// GetRangeUpper gets the RangeUpper of the DHCPServerRange.
func (m *DHCPServerRange) GetRangeUpper() (x string) {
	if m == nil {
		return x
	}
	return m.RangeUpper
}

// GetLeaseTime gets the LeaseTime of the DHCPServerRange.
func (m *DHCPServerRange) GetLeaseTime() (x string) {
	if m == nil {
		return x
	}
	return m.LeaseTime
}

// MarshalToWriter marshals DHCPServerRange to the provided writer.
func (m *DHCPServerRange) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.RangeLower) > 0 {
		writer.WriteString(1, m.RangeLower)
	}

	if len(m.RangeUpper) > 0 {
		writer.WriteString(2, m.RangeUpper)
	}

	if len(m.LeaseTime) > 0 {
		writer.WriteString(3, m.LeaseTime)
	}

	return
}

// Marshal marshals DHCPServerRange to a slice of bytes.
func (m *DHCPServerRange) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerRange from the provided reader.
func (m *DHCPServerRange) UnmarshalFromReader(reader jspb.Reader) *DHCPServerRange {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerRange{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.RangeLower = reader.ReadString()
		case 2:
			m.RangeUpper = reader.ReadString()
		case 3:
			m.LeaseTime = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerRange from a slice of bytes.
func (m *DHCPServerRange) Unmarshal(rawBytes []byte) (*DHCPServerRange, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Used for static leases
type DHCPServerStaticHost struct {
	Mac string
	Ip  string
}

// GetMac gets the Mac of the DHCPServerStaticHost.
func (m *DHCPServerStaticHost) GetMac() (x string) {
	if m == nil {
		return x
	}
	return m.Mac
}

// GetIp gets the Ip of the DHCPServerStaticHost.
func (m *DHCPServerStaticHost) GetIp() (x string) {
	if m == nil {
		return x
	}
	return m.Ip
}

// MarshalToWriter marshals DHCPServerStaticHost to the provided writer.
func (m *DHCPServerStaticHost) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Mac) > 0 {
		writer.WriteString(1, m.Mac)
	}

	if len(m.Ip) > 0 {
		writer.WriteString(2, m.Ip)
	}

	return
}

// Marshal marshals DHCPServerStaticHost to a slice of bytes.
func (m *DHCPServerStaticHost) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerStaticHost from the provided reader.
func (m *DHCPServerStaticHost) UnmarshalFromReader(reader jspb.Reader) *DHCPServerStaticHost {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerStaticHost{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Mac = reader.ReadString()
		case 2:
			m.Ip = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerStaticHost from a slice of bytes.
func (m *DHCPServerStaticHost) Unmarshal(rawBytes []byte) (*DHCPServerStaticHost, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// WiFi
type WiFiSettings struct {
	Diasabled     bool
	Reg           string
	Mode          WiFiSettings_Mode
	ApSsid        string
	AuthMode      WiFiSettings_APAuthMode
	ApChannel     uint32
	ApPsk         string
	ApHideSsid    bool
	ClientSsid    string
	ClientPsk     string
	DisableNexmon bool
}

// GetDiasabled gets the Diasabled of the WiFiSettings.
func (m *WiFiSettings) GetDiasabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Diasabled
}

// GetReg gets the Reg of the WiFiSettings.
func (m *WiFiSettings) GetReg() (x string) {
	if m == nil {
		return x
	}
	return m.Reg
}

// GetMode gets the Mode of the WiFiSettings.
func (m *WiFiSettings) GetMode() (x WiFiSettings_Mode) {
	if m == nil {
		return x
	}
	return m.Mode
}

// GetApSsid gets the ApSsid of the WiFiSettings.
func (m *WiFiSettings) GetApSsid() (x string) {
	if m == nil {
		return x
	}
	return m.ApSsid
}

// GetAuthMode gets the AuthMode of the WiFiSettings.
func (m *WiFiSettings) GetAuthMode() (x WiFiSettings_APAuthMode) {
	if m == nil {
		return x
	}
	return m.AuthMode
}

// GetApChannel gets the ApChannel of the WiFiSettings.
func (m *WiFiSettings) GetApChannel() (x uint32) {
	if m == nil {
		return x
	}
	return m.ApChannel
}

// GetApPsk gets the ApPsk of the WiFiSettings.
func (m *WiFiSettings) GetApPsk() (x string) {
	if m == nil {
		return x
	}
	return m.ApPsk
}

// GetApHideSsid gets the ApHideSsid of the WiFiSettings.
func (m *WiFiSettings) GetApHideSsid() (x bool) {
	if m == nil {
		return x
	}
	return m.ApHideSsid
}

// GetClientSsid gets the ClientSsid of the WiFiSettings.
func (m *WiFiSettings) GetClientSsid() (x string) {
	if m == nil {
		return x
	}
	return m.ClientSsid
}

// GetClientPsk gets the ClientPsk of the WiFiSettings.
func (m *WiFiSettings) GetClientPsk() (x string) {
	if m == nil {
		return x
	}
	return m.ClientPsk
}

// GetDisableNexmon gets the DisableNexmon of the WiFiSettings.
func (m *WiFiSettings) GetDisableNexmon() (x bool) {
	if m == nil {
		return x
	}
	return m.DisableNexmon
}

// MarshalToWriter marshals WiFiSettings to the provided writer.
func (m *WiFiSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Diasabled {
		writer.WriteBool(1, m.Diasabled)
	}

	if len(m.Reg) > 0 {
		writer.WriteString(2, m.Reg)
	}

	if int(m.Mode) != 0 {
		writer.WriteEnum(3, int(m.Mode))
	}

	if len(m.ApSsid) > 0 {
		writer.WriteString(4, m.ApSsid)
	}

	if int(m.AuthMode) != 0 {
		writer.WriteEnum(5, int(m.AuthMode))
	}

	if m.ApChannel != 0 {
		writer.WriteUint32(6, m.ApChannel)
	}

	if len(m.ApPsk) > 0 {
		writer.WriteString(7, m.ApPsk)
	}

	if m.ApHideSsid {
		writer.WriteBool(8, m.ApHideSsid)
	}

	if len(m.ClientSsid) > 0 {
		writer.WriteString(9, m.ClientSsid)
	}

	if len(m.ClientPsk) > 0 {
		writer.WriteString(10, m.ClientPsk)
	}

	if m.DisableNexmon {
		writer.WriteBool(11, m.DisableNexmon)
	}

	return
}

// Marshal marshals WiFiSettings to a slice of bytes.
func (m *WiFiSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WiFiSettings from the provided reader.
func (m *WiFiSettings) UnmarshalFromReader(reader jspb.Reader) *WiFiSettings {
	for reader.Next() {
		if m == nil {
			m = &WiFiSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Diasabled = reader.ReadBool()
		case 2:
			m.Reg = reader.ReadString()
		case 3:
			m.Mode = WiFiSettings_Mode(reader.ReadEnum())
		case 4:
			m.ApSsid = reader.ReadString()
		case 5:
			m.AuthMode = WiFiSettings_APAuthMode(reader.ReadEnum())
		case 6:
			m.ApChannel = reader.ReadUint32()
		case 7:
			m.ApPsk = reader.ReadString()
		case 8:
			m.ApHideSsid = reader.ReadBool()
		case 9:
			m.ClientSsid = reader.ReadString()
		case 10:
			m.ClientPsk = reader.ReadString()
		case 11:
			m.DisableNexmon = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WiFiSettings from a slice of bytes.
func (m *WiFiSettings) Unmarshal(rawBytes []byte) (*WiFiSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Empty struct {
}

// MarshalToWriter marshals Empty to the provided writer.
func (m *Empty) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	return
}

// Marshal marshals Empty to a slice of bytes.
func (m *Empty) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Empty from the provided reader.
func (m *Empty) UnmarshalFromReader(reader jspb.Reader) *Empty {
	for reader.Next() {
		if m == nil {
			m = &Empty{}
		}

		switch reader.GetFieldNumber() {
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Empty from a slice of bytes.
func (m *Empty) Unmarshal(rawBytes []byte) (*Empty, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for P4WNP1 service

type P4WNP1Client interface {
	GetDeployedGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	DeployGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	GetGadgetSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	SetGadgetSettings(ctx context.Context, in *GadgetSettings, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	GetLEDSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*LEDSettings, error)
	SetLEDSettings(ctx context.Context, in *LEDSettings, opts ...grpcweb.CallOption) (*Empty, error)
	MountUMSFile(ctx context.Context, in *GadgetSettingsUMS, opts ...grpcweb.CallOption) (*Empty, error)
	DeployEthernetInterfaceSettings(ctx context.Context, in *EthernetInterfaceSettings, opts ...grpcweb.CallOption) (*Empty, error)
}

type p4WNP1Client struct {
	client *grpcweb.Client
}

// NewP4WNP1Client creates a new gRPC-Web client.
func NewP4WNP1Client(hostname string, opts ...grpcweb.DialOption) P4WNP1Client {
	return &p4WNP1Client{
		client: grpcweb.NewClient(hostname, "P4wnP1_grpc.P4WNP1", opts...),
	}
}

func (c *p4WNP1Client) GetDeployedGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetDeployedGadgetSetting", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "DeployGadgetSetting", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) GetGadgetSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetGadgetSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) SetGadgetSettings(ctx context.Context, in *GadgetSettings, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "SetGadgetSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) GetLEDSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*LEDSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetLEDSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(LEDSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) SetLEDSettings(ctx context.Context, in *LEDSettings, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "SetLEDSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) MountUMSFile(ctx context.Context, in *GadgetSettingsUMS, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "MountUMSFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployEthernetInterfaceSettings(ctx context.Context, in *EthernetInterfaceSettings, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "DeployEthernetInterfaceSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}
