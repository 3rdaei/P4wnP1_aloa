// Code generated by protoc-gen-gopherjs. DO NOT EDIT.
// source: grpc.proto

/*
	Package P4wnP1_grpc is a generated protocol buffer package.

	It is generated from these files:
		grpc.proto

	It has these top-level messages:
		TempDirOrFileRequest
		TempDirOrFileResponse
		ReadFileRequest
		ReadFileResponse
		WriteFileRequest
		FileInfoRequest
		FileInfoResponse
		HIDScriptRequest
		HIDScriptJob
		HIDScriptResult
		LEDSettings
		GadgetSettings
		GadgetSettingsEthernet
		GadgetSettingsUMS
		EthernetInterfaceSettings
		DHCPServerSettings
		DHCPServerRange
		DHCPServerStaticHost
		WiFiSettings
		BSSCfg
		Empty
*/
package P4wnP1_grpc

import jspb "github.com/johanbrandhorst/protobuf/jspb"

import (
	context "context"

	grpcweb "github.com/johanbrandhorst/protobuf/grpcweb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the jspb package it is being compiled against.
const _ = jspb.JspbPackageIsVersion2

type EthernetInterfaceSettings_Mode int

const (
	EthernetInterfaceSettings_MANUAL      EthernetInterfaceSettings_Mode = 0
	EthernetInterfaceSettings_DHCP_CLIENT EthernetInterfaceSettings_Mode = 1
	EthernetInterfaceSettings_DHCP_SERVER EthernetInterfaceSettings_Mode = 2
)

var EthernetInterfaceSettings_Mode_name = map[int]string{
	0: "MANUAL",
	1: "DHCP_CLIENT",
	2: "DHCP_SERVER",
}
var EthernetInterfaceSettings_Mode_value = map[string]int{
	"MANUAL":      0,
	"DHCP_CLIENT": 1,
	"DHCP_SERVER": 2,
}

func (x EthernetInterfaceSettings_Mode) String() string {
	return EthernetInterfaceSettings_Mode_name[int(x)]
}

type WiFiSettings_Mode int

const (
	WiFiSettings_AP              WiFiSettings_Mode = 0
	WiFiSettings_STA             WiFiSettings_Mode = 1
	WiFiSettings_STA_FAILOVER_AP WiFiSettings_Mode = 2
)

var WiFiSettings_Mode_name = map[int]string{
	0: "AP",
	1: "STA",
	2: "STA_FAILOVER_AP",
}
var WiFiSettings_Mode_value = map[string]int{
	"AP":              0,
	"STA":             1,
	"STA_FAILOVER_AP": 2,
}

func (x WiFiSettings_Mode) String() string {
	return WiFiSettings_Mode_name[int(x)]
}

type WiFiSettings_APAuthMode int

const (
	WiFiSettings_WPA2_PSK WiFiSettings_APAuthMode = 0
	WiFiSettings_OPEN     WiFiSettings_APAuthMode = 1
)

var WiFiSettings_APAuthMode_name = map[int]string{
	0: "WPA2_PSK",
	1: "OPEN",
}
var WiFiSettings_APAuthMode_value = map[string]int{
	"WPA2_PSK": 0,
	"OPEN":     1,
}

func (x WiFiSettings_APAuthMode) String() string {
	return WiFiSettings_APAuthMode_name[int(x)]
}

// File System
type TempDirOrFileRequest struct {
	Dir        string
	Prefix     string
	OnlyFolder bool
}

// GetDir gets the Dir of the TempDirOrFileRequest.
func (m *TempDirOrFileRequest) GetDir() (x string) {
	if m == nil {
		return x
	}
	return m.Dir
}

// GetPrefix gets the Prefix of the TempDirOrFileRequest.
func (m *TempDirOrFileRequest) GetPrefix() (x string) {
	if m == nil {
		return x
	}
	return m.Prefix
}

// GetOnlyFolder gets the OnlyFolder of the TempDirOrFileRequest.
func (m *TempDirOrFileRequest) GetOnlyFolder() (x bool) {
	if m == nil {
		return x
	}
	return m.OnlyFolder
}

// MarshalToWriter marshals TempDirOrFileRequest to the provided writer.
func (m *TempDirOrFileRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Dir) > 0 {
		writer.WriteString(1, m.Dir)
	}

	if len(m.Prefix) > 0 {
		writer.WriteString(2, m.Prefix)
	}

	if m.OnlyFolder {
		writer.WriteBool(3, m.OnlyFolder)
	}

	return
}

// Marshal marshals TempDirOrFileRequest to a slice of bytes.
func (m *TempDirOrFileRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TempDirOrFileRequest from the provided reader.
func (m *TempDirOrFileRequest) UnmarshalFromReader(reader jspb.Reader) *TempDirOrFileRequest {
	for reader.Next() {
		if m == nil {
			m = &TempDirOrFileRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Dir = reader.ReadString()
		case 2:
			m.Prefix = reader.ReadString()
		case 3:
			m.OnlyFolder = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TempDirOrFileRequest from a slice of bytes.
func (m *TempDirOrFileRequest) Unmarshal(rawBytes []byte) (*TempDirOrFileRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type TempDirOrFileResponse struct {
	ResultPath string
}

// GetResultPath gets the ResultPath of the TempDirOrFileResponse.
func (m *TempDirOrFileResponse) GetResultPath() (x string) {
	if m == nil {
		return x
	}
	return m.ResultPath
}

// MarshalToWriter marshals TempDirOrFileResponse to the provided writer.
func (m *TempDirOrFileResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.ResultPath) > 0 {
		writer.WriteString(1, m.ResultPath)
	}

	return
}

// Marshal marshals TempDirOrFileResponse to a slice of bytes.
func (m *TempDirOrFileResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a TempDirOrFileResponse from the provided reader.
func (m *TempDirOrFileResponse) UnmarshalFromReader(reader jspb.Reader) *TempDirOrFileResponse {
	for reader.Next() {
		if m == nil {
			m = &TempDirOrFileResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ResultPath = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a TempDirOrFileResponse from a slice of bytes.
func (m *TempDirOrFileResponse) Unmarshal(rawBytes []byte) (*TempDirOrFileResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ReadFileRequest struct {
	Path  string
	Start int64
	Data  []byte
}

// GetPath gets the Path of the ReadFileRequest.
func (m *ReadFileRequest) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// GetStart gets the Start of the ReadFileRequest.
func (m *ReadFileRequest) GetStart() (x int64) {
	if m == nil {
		return x
	}
	return m.Start
}

// GetData gets the Data of the ReadFileRequest.
func (m *ReadFileRequest) GetData() (x []byte) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals ReadFileRequest to the provided writer.
func (m *ReadFileRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	if m.Start != 0 {
		writer.WriteInt64(2, m.Start)
	}

	if len(m.Data) > 0 {
		writer.WriteBytes(3, m.Data)
	}

	return
}

// Marshal marshals ReadFileRequest to a slice of bytes.
func (m *ReadFileRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ReadFileRequest from the provided reader.
func (m *ReadFileRequest) UnmarshalFromReader(reader jspb.Reader) *ReadFileRequest {
	for reader.Next() {
		if m == nil {
			m = &ReadFileRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		case 2:
			m.Start = reader.ReadInt64()
		case 3:
			m.Data = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ReadFileRequest from a slice of bytes.
func (m *ReadFileRequest) Unmarshal(rawBytes []byte) (*ReadFileRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type ReadFileResponse struct {
	ReadCount int64
}

// GetReadCount gets the ReadCount of the ReadFileResponse.
func (m *ReadFileResponse) GetReadCount() (x int64) {
	if m == nil {
		return x
	}
	return m.ReadCount
}

// MarshalToWriter marshals ReadFileResponse to the provided writer.
func (m *ReadFileResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ReadCount != 0 {
		writer.WriteInt64(1, m.ReadCount)
	}

	return
}

// Marshal marshals ReadFileResponse to a slice of bytes.
func (m *ReadFileResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a ReadFileResponse from the provided reader.
func (m *ReadFileResponse) UnmarshalFromReader(reader jspb.Reader) *ReadFileResponse {
	for reader.Next() {
		if m == nil {
			m = &ReadFileResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ReadCount = reader.ReadInt64()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a ReadFileResponse from a slice of bytes.
func (m *ReadFileResponse) Unmarshal(rawBytes []byte) (*ReadFileResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type WriteFileRequest struct {
	Path         string
	Append       bool
	MustNotExist bool
	Data         []byte
}

// GetPath gets the Path of the WriteFileRequest.
func (m *WriteFileRequest) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// GetAppend gets the Append of the WriteFileRequest.
func (m *WriteFileRequest) GetAppend() (x bool) {
	if m == nil {
		return x
	}
	return m.Append
}

// GetMustNotExist gets the MustNotExist of the WriteFileRequest.
func (m *WriteFileRequest) GetMustNotExist() (x bool) {
	if m == nil {
		return x
	}
	return m.MustNotExist
}

// GetData gets the Data of the WriteFileRequest.
func (m *WriteFileRequest) GetData() (x []byte) {
	if m == nil {
		return x
	}
	return m.Data
}

// MarshalToWriter marshals WriteFileRequest to the provided writer.
func (m *WriteFileRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	if m.Append {
		writer.WriteBool(2, m.Append)
	}

	if m.MustNotExist {
		writer.WriteBool(3, m.MustNotExist)
	}

	if len(m.Data) > 0 {
		writer.WriteBytes(4, m.Data)
	}

	return
}

// Marshal marshals WriteFileRequest to a slice of bytes.
func (m *WriteFileRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WriteFileRequest from the provided reader.
func (m *WriteFileRequest) UnmarshalFromReader(reader jspb.Reader) *WriteFileRequest {
	for reader.Next() {
		if m == nil {
			m = &WriteFileRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		case 2:
			m.Append = reader.ReadBool()
		case 3:
			m.MustNotExist = reader.ReadBool()
		case 4:
			m.Data = reader.ReadBytes()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WriteFileRequest from a slice of bytes.
func (m *WriteFileRequest) Unmarshal(rawBytes []byte) (*WriteFileRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type FileInfoRequest struct {
	Path string
}

// GetPath gets the Path of the FileInfoRequest.
func (m *FileInfoRequest) GetPath() (x string) {
	if m == nil {
		return x
	}
	return m.Path
}

// MarshalToWriter marshals FileInfoRequest to the provided writer.
func (m *FileInfoRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Path) > 0 {
		writer.WriteString(1, m.Path)
	}

	return
}

// Marshal marshals FileInfoRequest to a slice of bytes.
func (m *FileInfoRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a FileInfoRequest from the provided reader.
func (m *FileInfoRequest) UnmarshalFromReader(reader jspb.Reader) *FileInfoRequest {
	for reader.Next() {
		if m == nil {
			m = &FileInfoRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Path = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a FileInfoRequest from a slice of bytes.
func (m *FileInfoRequest) Unmarshal(rawBytes []byte) (*FileInfoRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type FileInfoResponse struct {
	Name    string
	Size    int64
	Mode    uint32
	ModTime int64
	IsDir   bool
}

// GetName gets the Name of the FileInfoResponse.
func (m *FileInfoResponse) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetSize gets the Size of the FileInfoResponse.
func (m *FileInfoResponse) GetSize() (x int64) {
	if m == nil {
		return x
	}
	return m.Size
}

// GetMode gets the Mode of the FileInfoResponse.
func (m *FileInfoResponse) GetMode() (x uint32) {
	if m == nil {
		return x
	}
	return m.Mode
}

// GetModTime gets the ModTime of the FileInfoResponse.
func (m *FileInfoResponse) GetModTime() (x int64) {
	if m == nil {
		return x
	}
	return m.ModTime
}

// GetIsDir gets the IsDir of the FileInfoResponse.
func (m *FileInfoResponse) GetIsDir() (x bool) {
	if m == nil {
		return x
	}
	return m.IsDir
}

// MarshalToWriter marshals FileInfoResponse to the provided writer.
func (m *FileInfoResponse) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Name) > 0 {
		writer.WriteString(1, m.Name)
	}

	if m.Size != 0 {
		writer.WriteInt64(2, m.Size)
	}

	if m.Mode != 0 {
		writer.WriteUint32(3, m.Mode)
	}

	if m.ModTime != 0 {
		writer.WriteInt64(4, m.ModTime)
	}

	if m.IsDir {
		writer.WriteBool(5, m.IsDir)
	}

	return
}

// Marshal marshals FileInfoResponse to a slice of bytes.
func (m *FileInfoResponse) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a FileInfoResponse from the provided reader.
func (m *FileInfoResponse) UnmarshalFromReader(reader jspb.Reader) *FileInfoResponse {
	for reader.Next() {
		if m == nil {
			m = &FileInfoResponse{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Name = reader.ReadString()
		case 2:
			m.Size = reader.ReadInt64()
		case 3:
			m.Mode = reader.ReadUint32()
		case 4:
			m.ModTime = reader.ReadInt64()
		case 5:
			m.IsDir = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a FileInfoResponse from a slice of bytes.
func (m *FileInfoResponse) Unmarshal(rawBytes []byte) (*FileInfoResponse, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// HID
type HIDScriptRequest struct {
	ScriptPath     string
	TimeoutSeconds uint32
}

// GetScriptPath gets the ScriptPath of the HIDScriptRequest.
func (m *HIDScriptRequest) GetScriptPath() (x string) {
	if m == nil {
		return x
	}
	return m.ScriptPath
}

// GetTimeoutSeconds gets the TimeoutSeconds of the HIDScriptRequest.
func (m *HIDScriptRequest) GetTimeoutSeconds() (x uint32) {
	if m == nil {
		return x
	}
	return m.TimeoutSeconds
}

// MarshalToWriter marshals HIDScriptRequest to the provided writer.
func (m *HIDScriptRequest) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.ScriptPath) > 0 {
		writer.WriteString(1, m.ScriptPath)
	}

	if m.TimeoutSeconds != 0 {
		writer.WriteUint32(2, m.TimeoutSeconds)
	}

	return
}

// Marshal marshals HIDScriptRequest to a slice of bytes.
func (m *HIDScriptRequest) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDScriptRequest from the provided reader.
func (m *HIDScriptRequest) UnmarshalFromReader(reader jspb.Reader) *HIDScriptRequest {
	for reader.Next() {
		if m == nil {
			m = &HIDScriptRequest{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ScriptPath = reader.ReadString()
		case 2:
			m.TimeoutSeconds = reader.ReadUint32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDScriptRequest from a slice of bytes.
func (m *HIDScriptRequest) Unmarshal(rawBytes []byte) (*HIDScriptRequest, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HIDScriptJob struct {
	Id uint32
}

// GetId gets the Id of the HIDScriptJob.
func (m *HIDScriptJob) GetId() (x uint32) {
	if m == nil {
		return x
	}
	return m.Id
}

// MarshalToWriter marshals HIDScriptJob to the provided writer.
func (m *HIDScriptJob) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Id != 0 {
		writer.WriteUint32(1, m.Id)
	}

	return
}

// Marshal marshals HIDScriptJob to a slice of bytes.
func (m *HIDScriptJob) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDScriptJob from the provided reader.
func (m *HIDScriptJob) UnmarshalFromReader(reader jspb.Reader) *HIDScriptJob {
	for reader.Next() {
		if m == nil {
			m = &HIDScriptJob{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Id = reader.ReadUint32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDScriptJob from a slice of bytes.
func (m *HIDScriptJob) Unmarshal(rawBytes []byte) (*HIDScriptJob, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type HIDScriptResult struct {
	Job        *HIDScriptJob
	IsFinished bool
	ResultJson string
}

// GetJob gets the Job of the HIDScriptResult.
func (m *HIDScriptResult) GetJob() (x *HIDScriptJob) {
	if m == nil {
		return x
	}
	return m.Job
}

// GetIsFinished gets the IsFinished of the HIDScriptResult.
func (m *HIDScriptResult) GetIsFinished() (x bool) {
	if m == nil {
		return x
	}
	return m.IsFinished
}

// GetResultJson gets the ResultJson of the HIDScriptResult.
func (m *HIDScriptResult) GetResultJson() (x string) {
	if m == nil {
		return x
	}
	return m.ResultJson
}

// MarshalToWriter marshals HIDScriptResult to the provided writer.
func (m *HIDScriptResult) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Job != nil {
		writer.WriteMessage(1, func() {
			m.Job.MarshalToWriter(writer)
		})
	}

	if m.IsFinished {
		writer.WriteBool(2, m.IsFinished)
	}

	if len(m.ResultJson) > 0 {
		writer.WriteString(3, m.ResultJson)
	}

	return
}

// Marshal marshals HIDScriptResult to a slice of bytes.
func (m *HIDScriptResult) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a HIDScriptResult from the provided reader.
func (m *HIDScriptResult) UnmarshalFromReader(reader jspb.Reader) *HIDScriptResult {
	for reader.Next() {
		if m == nil {
			m = &HIDScriptResult{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			reader.ReadMessage(func() {
				m.Job = m.Job.UnmarshalFromReader(reader)
			})
		case 2:
			m.IsFinished = reader.ReadBool()
		case 3:
			m.ResultJson = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a HIDScriptResult from a slice of bytes.
func (m *HIDScriptResult) Unmarshal(rawBytes []byte) (*HIDScriptResult, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// LED
type LEDSettings struct {
	BlinkCount uint32
}

// GetBlinkCount gets the BlinkCount of the LEDSettings.
func (m *LEDSettings) GetBlinkCount() (x uint32) {
	if m == nil {
		return x
	}
	return m.BlinkCount
}

// MarshalToWriter marshals LEDSettings to the provided writer.
func (m *LEDSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.BlinkCount != 0 {
		writer.WriteUint32(1, m.BlinkCount)
	}

	return
}

// Marshal marshals LEDSettings to a slice of bytes.
func (m *LEDSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a LEDSettings from the provided reader.
func (m *LEDSettings) UnmarshalFromReader(reader jspb.Reader) *LEDSettings {
	for reader.Next() {
		if m == nil {
			m = &LEDSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.BlinkCount = reader.ReadUint32()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a LEDSettings from a slice of bytes.
func (m *LEDSettings) Unmarshal(rawBytes []byte) (*LEDSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// USB Gadget
type GadgetSettings struct {
	Enabled          bool
	Vid              string
	Pid              string
	Manufacturer     string
	Product          string
	Serial           string
	Use_CDC_ECM      bool
	Use_RNDIS        bool
	Use_HID_KEYBOARD bool
	Use_HID_MOUSE    bool
	Use_HID_RAW      bool
	Use_UMS          bool
	Use_SERIAL       bool
	RndisSettings    *GadgetSettingsEthernet
	CdcEcmSettings   *GadgetSettingsEthernet
	UmsSettings      *GadgetSettingsUMS
}

// GetEnabled gets the Enabled of the GadgetSettings.
func (m *GadgetSettings) GetEnabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Enabled
}

// GetVid gets the Vid of the GadgetSettings.
func (m *GadgetSettings) GetVid() (x string) {
	if m == nil {
		return x
	}
	return m.Vid
}

// GetPid gets the Pid of the GadgetSettings.
func (m *GadgetSettings) GetPid() (x string) {
	if m == nil {
		return x
	}
	return m.Pid
}

// GetManufacturer gets the Manufacturer of the GadgetSettings.
func (m *GadgetSettings) GetManufacturer() (x string) {
	if m == nil {
		return x
	}
	return m.Manufacturer
}

// GetProduct gets the Product of the GadgetSettings.
func (m *GadgetSettings) GetProduct() (x string) {
	if m == nil {
		return x
	}
	return m.Product
}

// GetSerial gets the Serial of the GadgetSettings.
func (m *GadgetSettings) GetSerial() (x string) {
	if m == nil {
		return x
	}
	return m.Serial
}

// GetUse_CDC_ECM gets the Use_CDC_ECM of the GadgetSettings.
func (m *GadgetSettings) GetUse_CDC_ECM() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_CDC_ECM
}

// GetUse_RNDIS gets the Use_RNDIS of the GadgetSettings.
func (m *GadgetSettings) GetUse_RNDIS() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_RNDIS
}

// GetUse_HID_KEYBOARD gets the Use_HID_KEYBOARD of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_KEYBOARD() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_KEYBOARD
}

// GetUse_HID_MOUSE gets the Use_HID_MOUSE of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_MOUSE() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_MOUSE
}

// GetUse_HID_RAW gets the Use_HID_RAW of the GadgetSettings.
func (m *GadgetSettings) GetUse_HID_RAW() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_HID_RAW
}

// GetUse_UMS gets the Use_UMS of the GadgetSettings.
func (m *GadgetSettings) GetUse_UMS() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_UMS
}

// GetUse_SERIAL gets the Use_SERIAL of the GadgetSettings.
func (m *GadgetSettings) GetUse_SERIAL() (x bool) {
	if m == nil {
		return x
	}
	return m.Use_SERIAL
}

// GetRndisSettings gets the RndisSettings of the GadgetSettings.
func (m *GadgetSettings) GetRndisSettings() (x *GadgetSettingsEthernet) {
	if m == nil {
		return x
	}
	return m.RndisSettings
}

// GetCdcEcmSettings gets the CdcEcmSettings of the GadgetSettings.
func (m *GadgetSettings) GetCdcEcmSettings() (x *GadgetSettingsEthernet) {
	if m == nil {
		return x
	}
	return m.CdcEcmSettings
}

// GetUmsSettings gets the UmsSettings of the GadgetSettings.
func (m *GadgetSettings) GetUmsSettings() (x *GadgetSettingsUMS) {
	if m == nil {
		return x
	}
	return m.UmsSettings
}

// MarshalToWriter marshals GadgetSettings to the provided writer.
func (m *GadgetSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Enabled {
		writer.WriteBool(1, m.Enabled)
	}

	if len(m.Vid) > 0 {
		writer.WriteString(2, m.Vid)
	}

	if len(m.Pid) > 0 {
		writer.WriteString(3, m.Pid)
	}

	if len(m.Manufacturer) > 0 {
		writer.WriteString(4, m.Manufacturer)
	}

	if len(m.Product) > 0 {
		writer.WriteString(5, m.Product)
	}

	if len(m.Serial) > 0 {
		writer.WriteString(6, m.Serial)
	}

	if m.Use_CDC_ECM {
		writer.WriteBool(7, m.Use_CDC_ECM)
	}

	if m.Use_RNDIS {
		writer.WriteBool(8, m.Use_RNDIS)
	}

	if m.Use_HID_KEYBOARD {
		writer.WriteBool(9, m.Use_HID_KEYBOARD)
	}

	if m.Use_HID_MOUSE {
		writer.WriteBool(10, m.Use_HID_MOUSE)
	}

	if m.Use_HID_RAW {
		writer.WriteBool(11, m.Use_HID_RAW)
	}

	if m.Use_UMS {
		writer.WriteBool(12, m.Use_UMS)
	}

	if m.Use_SERIAL {
		writer.WriteBool(13, m.Use_SERIAL)
	}

	if m.RndisSettings != nil {
		writer.WriteMessage(14, func() {
			m.RndisSettings.MarshalToWriter(writer)
		})
	}

	if m.CdcEcmSettings != nil {
		writer.WriteMessage(15, func() {
			m.CdcEcmSettings.MarshalToWriter(writer)
		})
	}

	if m.UmsSettings != nil {
		writer.WriteMessage(16, func() {
			m.UmsSettings.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals GadgetSettings to a slice of bytes.
func (m *GadgetSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettings from the provided reader.
func (m *GadgetSettings) UnmarshalFromReader(reader jspb.Reader) *GadgetSettings {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Enabled = reader.ReadBool()
		case 2:
			m.Vid = reader.ReadString()
		case 3:
			m.Pid = reader.ReadString()
		case 4:
			m.Manufacturer = reader.ReadString()
		case 5:
			m.Product = reader.ReadString()
		case 6:
			m.Serial = reader.ReadString()
		case 7:
			m.Use_CDC_ECM = reader.ReadBool()
		case 8:
			m.Use_RNDIS = reader.ReadBool()
		case 9:
			m.Use_HID_KEYBOARD = reader.ReadBool()
		case 10:
			m.Use_HID_MOUSE = reader.ReadBool()
		case 11:
			m.Use_HID_RAW = reader.ReadBool()
		case 12:
			m.Use_UMS = reader.ReadBool()
		case 13:
			m.Use_SERIAL = reader.ReadBool()
		case 14:
			reader.ReadMessage(func() {
				m.RndisSettings = m.RndisSettings.UnmarshalFromReader(reader)
			})
		case 15:
			reader.ReadMessage(func() {
				m.CdcEcmSettings = m.CdcEcmSettings.UnmarshalFromReader(reader)
			})
		case 16:
			reader.ReadMessage(func() {
				m.UmsSettings = m.UmsSettings.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettings from a slice of bytes.
func (m *GadgetSettings) Unmarshal(rawBytes []byte) (*GadgetSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GadgetSettingsEthernet struct {
	HostAddr string
	DevAddr  string
}

// GetHostAddr gets the HostAddr of the GadgetSettingsEthernet.
func (m *GadgetSettingsEthernet) GetHostAddr() (x string) {
	if m == nil {
		return x
	}
	return m.HostAddr
}

// GetDevAddr gets the DevAddr of the GadgetSettingsEthernet.
func (m *GadgetSettingsEthernet) GetDevAddr() (x string) {
	if m == nil {
		return x
	}
	return m.DevAddr
}

// MarshalToWriter marshals GadgetSettingsEthernet to the provided writer.
func (m *GadgetSettingsEthernet) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.HostAddr) > 0 {
		writer.WriteString(1, m.HostAddr)
	}

	if len(m.DevAddr) > 0 {
		writer.WriteString(2, m.DevAddr)
	}

	return
}

// Marshal marshals GadgetSettingsEthernet to a slice of bytes.
func (m *GadgetSettingsEthernet) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettingsEthernet from the provided reader.
func (m *GadgetSettingsEthernet) UnmarshalFromReader(reader jspb.Reader) *GadgetSettingsEthernet {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettingsEthernet{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.HostAddr = reader.ReadString()
		case 2:
			m.DevAddr = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettingsEthernet from a slice of bytes.
func (m *GadgetSettingsEthernet) Unmarshal(rawBytes []byte) (*GadgetSettingsEthernet, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type GadgetSettingsUMS struct {
	Cdrom bool
	File  string
}

// GetCdrom gets the Cdrom of the GadgetSettingsUMS.
func (m *GadgetSettingsUMS) GetCdrom() (x bool) {
	if m == nil {
		return x
	}
	return m.Cdrom
}

// GetFile gets the File of the GadgetSettingsUMS.
func (m *GadgetSettingsUMS) GetFile() (x string) {
	if m == nil {
		return x
	}
	return m.File
}

// MarshalToWriter marshals GadgetSettingsUMS to the provided writer.
func (m *GadgetSettingsUMS) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Cdrom {
		writer.WriteBool(1, m.Cdrom)
	}

	if len(m.File) > 0 {
		writer.WriteString(2, m.File)
	}

	return
}

// Marshal marshals GadgetSettingsUMS to a slice of bytes.
func (m *GadgetSettingsUMS) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a GadgetSettingsUMS from the provided reader.
func (m *GadgetSettingsUMS) UnmarshalFromReader(reader jspb.Reader) *GadgetSettingsUMS {
	for reader.Next() {
		if m == nil {
			m = &GadgetSettingsUMS{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Cdrom = reader.ReadBool()
		case 2:
			m.File = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a GadgetSettingsUMS from a slice of bytes.
func (m *GadgetSettingsUMS) Unmarshal(rawBytes []byte) (*GadgetSettingsUMS, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type EthernetInterfaceSettings struct {
	Name               string
	Mode               EthernetInterfaceSettings_Mode
	IpAddress4         string
	Netmask4           string
	Enabled            bool
	DhcpServerSettings *DHCPServerSettings
}

// GetName gets the Name of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetName() (x string) {
	if m == nil {
		return x
	}
	return m.Name
}

// GetMode gets the Mode of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetMode() (x EthernetInterfaceSettings_Mode) {
	if m == nil {
		return x
	}
	return m.Mode
}

// GetIpAddress4 gets the IpAddress4 of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetIpAddress4() (x string) {
	if m == nil {
		return x
	}
	return m.IpAddress4
}

// GetNetmask4 gets the Netmask4 of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetNetmask4() (x string) {
	if m == nil {
		return x
	}
	return m.Netmask4
}

// GetEnabled gets the Enabled of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetEnabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Enabled
}

// GetDhcpServerSettings gets the DhcpServerSettings of the EthernetInterfaceSettings.
func (m *EthernetInterfaceSettings) GetDhcpServerSettings() (x *DHCPServerSettings) {
	if m == nil {
		return x
	}
	return m.DhcpServerSettings
}

// MarshalToWriter marshals EthernetInterfaceSettings to the provided writer.
func (m *EthernetInterfaceSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Name) > 0 {
		writer.WriteString(1, m.Name)
	}

	if int(m.Mode) != 0 {
		writer.WriteEnum(2, int(m.Mode))
	}

	if len(m.IpAddress4) > 0 {
		writer.WriteString(3, m.IpAddress4)
	}

	if len(m.Netmask4) > 0 {
		writer.WriteString(4, m.Netmask4)
	}

	if m.Enabled {
		writer.WriteBool(5, m.Enabled)
	}

	if m.DhcpServerSettings != nil {
		writer.WriteMessage(6, func() {
			m.DhcpServerSettings.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals EthernetInterfaceSettings to a slice of bytes.
func (m *EthernetInterfaceSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a EthernetInterfaceSettings from the provided reader.
func (m *EthernetInterfaceSettings) UnmarshalFromReader(reader jspb.Reader) *EthernetInterfaceSettings {
	for reader.Next() {
		if m == nil {
			m = &EthernetInterfaceSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Name = reader.ReadString()
		case 2:
			m.Mode = EthernetInterfaceSettings_Mode(reader.ReadEnum())
		case 3:
			m.IpAddress4 = reader.ReadString()
		case 4:
			m.Netmask4 = reader.ReadString()
		case 5:
			m.Enabled = reader.ReadBool()
		case 6:
			reader.ReadMessage(func() {
				m.DhcpServerSettings = m.DhcpServerSettings.UnmarshalFromReader(reader)
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a EthernetInterfaceSettings from a slice of bytes.
func (m *EthernetInterfaceSettings) Unmarshal(rawBytes []byte) (*EthernetInterfaceSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// DHCP
type DHCPServerSettings struct {
	ListenPort         uint32
	ListenInterface    string
	LeaseFile          string
	NotAuthoritative   bool
	DoNotBindInterface bool
	CallbackScript     string
	Ranges             []*DHCPServerRange
	// repeated DHCPServerOption options = 8;
	Options     map[uint32]string
	StaticHosts []*DHCPServerStaticHost
}

// GetListenPort gets the ListenPort of the DHCPServerSettings.
func (m *DHCPServerSettings) GetListenPort() (x uint32) {
	if m == nil {
		return x
	}
	return m.ListenPort
}

// GetListenInterface gets the ListenInterface of the DHCPServerSettings.
func (m *DHCPServerSettings) GetListenInterface() (x string) {
	if m == nil {
		return x
	}
	return m.ListenInterface
}

// GetLeaseFile gets the LeaseFile of the DHCPServerSettings.
func (m *DHCPServerSettings) GetLeaseFile() (x string) {
	if m == nil {
		return x
	}
	return m.LeaseFile
}

// GetNotAuthoritative gets the NotAuthoritative of the DHCPServerSettings.
func (m *DHCPServerSettings) GetNotAuthoritative() (x bool) {
	if m == nil {
		return x
	}
	return m.NotAuthoritative
}

// GetDoNotBindInterface gets the DoNotBindInterface of the DHCPServerSettings.
func (m *DHCPServerSettings) GetDoNotBindInterface() (x bool) {
	if m == nil {
		return x
	}
	return m.DoNotBindInterface
}

// GetCallbackScript gets the CallbackScript of the DHCPServerSettings.
func (m *DHCPServerSettings) GetCallbackScript() (x string) {
	if m == nil {
		return x
	}
	return m.CallbackScript
}

// GetRanges gets the Ranges of the DHCPServerSettings.
func (m *DHCPServerSettings) GetRanges() (x []*DHCPServerRange) {
	if m == nil {
		return x
	}
	return m.Ranges
}

// GetOptions gets the Options of the DHCPServerSettings.
func (m *DHCPServerSettings) GetOptions() (x map[uint32]string) {
	if m == nil {
		return x
	}
	return m.Options
}

// GetStaticHosts gets the StaticHosts of the DHCPServerSettings.
func (m *DHCPServerSettings) GetStaticHosts() (x []*DHCPServerStaticHost) {
	if m == nil {
		return x
	}
	return m.StaticHosts
}

// MarshalToWriter marshals DHCPServerSettings to the provided writer.
func (m *DHCPServerSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.ListenPort != 0 {
		writer.WriteUint32(1, m.ListenPort)
	}

	if len(m.ListenInterface) > 0 {
		writer.WriteString(2, m.ListenInterface)
	}

	if len(m.LeaseFile) > 0 {
		writer.WriteString(3, m.LeaseFile)
	}

	if m.NotAuthoritative {
		writer.WriteBool(4, m.NotAuthoritative)
	}

	if m.DoNotBindInterface {
		writer.WriteBool(5, m.DoNotBindInterface)
	}

	if len(m.CallbackScript) > 0 {
		writer.WriteString(6, m.CallbackScript)
	}

	for _, msg := range m.Ranges {
		writer.WriteMessage(7, func() {
			msg.MarshalToWriter(writer)
		})
	}

	if len(m.Options) > 0 {
		for key, value := range m.Options {
			writer.WriteMessage(8, func() {
				writer.WriteUint32(1, key)
				writer.WriteString(2, value)
			})
		}
	}

	for _, msg := range m.StaticHosts {
		writer.WriteMessage(9, func() {
			msg.MarshalToWriter(writer)
		})
	}

	return
}

// Marshal marshals DHCPServerSettings to a slice of bytes.
func (m *DHCPServerSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerSettings from the provided reader.
func (m *DHCPServerSettings) UnmarshalFromReader(reader jspb.Reader) *DHCPServerSettings {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.ListenPort = reader.ReadUint32()
		case 2:
			m.ListenInterface = reader.ReadString()
		case 3:
			m.LeaseFile = reader.ReadString()
		case 4:
			m.NotAuthoritative = reader.ReadBool()
		case 5:
			m.DoNotBindInterface = reader.ReadBool()
		case 6:
			m.CallbackScript = reader.ReadString()
		case 7:
			reader.ReadMessage(func() {
				m.Ranges = append(m.Ranges, new(DHCPServerRange).UnmarshalFromReader(reader))
			})
		case 8:
			if m.Options == nil {
				m.Options = map[uint32]string{}
			}
			reader.ReadMessage(func() {
				var key uint32
				var value string
				for reader.Next() {
					switch reader.GetFieldNumber() {
					case 1:
						key = reader.ReadUint32()
					case 2:
						value = reader.ReadString()
					}
					m.Options[key] = value
				}
			})
		case 9:
			reader.ReadMessage(func() {
				m.StaticHosts = append(m.StaticHosts, new(DHCPServerStaticHost).UnmarshalFromReader(reader))
			})
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerSettings from a slice of bytes.
func (m *DHCPServerSettings) Unmarshal(rawBytes []byte) (*DHCPServerSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Could be used for IPv4 or IPv6 (refer dnsmasq docs), nor field for prefix length (default is 64)
type DHCPServerRange struct {
	RangeLower string
	RangeUpper string
	LeaseTime  string
}

// GetRangeLower gets the RangeLower of the DHCPServerRange.
func (m *DHCPServerRange) GetRangeLower() (x string) {
	if m == nil {
		return x
	}
	return m.RangeLower
}

// GetRangeUpper gets the RangeUpper of the DHCPServerRange.
func (m *DHCPServerRange) GetRangeUpper() (x string) {
	if m == nil {
		return x
	}
	return m.RangeUpper
}

// GetLeaseTime gets the LeaseTime of the DHCPServerRange.
func (m *DHCPServerRange) GetLeaseTime() (x string) {
	if m == nil {
		return x
	}
	return m.LeaseTime
}

// MarshalToWriter marshals DHCPServerRange to the provided writer.
func (m *DHCPServerRange) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.RangeLower) > 0 {
		writer.WriteString(1, m.RangeLower)
	}

	if len(m.RangeUpper) > 0 {
		writer.WriteString(2, m.RangeUpper)
	}

	if len(m.LeaseTime) > 0 {
		writer.WriteString(3, m.LeaseTime)
	}

	return
}

// Marshal marshals DHCPServerRange to a slice of bytes.
func (m *DHCPServerRange) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerRange from the provided reader.
func (m *DHCPServerRange) UnmarshalFromReader(reader jspb.Reader) *DHCPServerRange {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerRange{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.RangeLower = reader.ReadString()
		case 2:
			m.RangeUpper = reader.ReadString()
		case 3:
			m.LeaseTime = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerRange from a slice of bytes.
func (m *DHCPServerRange) Unmarshal(rawBytes []byte) (*DHCPServerRange, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Used for static leases
type DHCPServerStaticHost struct {
	Mac string
	Ip  string
}

// GetMac gets the Mac of the DHCPServerStaticHost.
func (m *DHCPServerStaticHost) GetMac() (x string) {
	if m == nil {
		return x
	}
	return m.Mac
}

// GetIp gets the Ip of the DHCPServerStaticHost.
func (m *DHCPServerStaticHost) GetIp() (x string) {
	if m == nil {
		return x
	}
	return m.Ip
}

// MarshalToWriter marshals DHCPServerStaticHost to the provided writer.
func (m *DHCPServerStaticHost) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.Mac) > 0 {
		writer.WriteString(1, m.Mac)
	}

	if len(m.Ip) > 0 {
		writer.WriteString(2, m.Ip)
	}

	return
}

// Marshal marshals DHCPServerStaticHost to a slice of bytes.
func (m *DHCPServerStaticHost) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a DHCPServerStaticHost from the provided reader.
func (m *DHCPServerStaticHost) UnmarshalFromReader(reader jspb.Reader) *DHCPServerStaticHost {
	for reader.Next() {
		if m == nil {
			m = &DHCPServerStaticHost{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Mac = reader.ReadString()
		case 2:
			m.Ip = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a DHCPServerStaticHost from a slice of bytes.
func (m *DHCPServerStaticHost) Unmarshal(rawBytes []byte) (*DHCPServerStaticHost, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// WiFi
type WiFiSettings struct {
	Disabled      bool
	Reg           string
	Mode          WiFiSettings_Mode
	AuthMode      WiFiSettings_APAuthMode
	ApChannel     uint32
	BssCfgAP      *BSSCfg
	BssCfgClient  *BSSCfg
	ApHideSsid    bool
	DisableNexmon bool
}

// GetDisabled gets the Disabled of the WiFiSettings.
func (m *WiFiSettings) GetDisabled() (x bool) {
	if m == nil {
		return x
	}
	return m.Disabled
}

// GetReg gets the Reg of the WiFiSettings.
func (m *WiFiSettings) GetReg() (x string) {
	if m == nil {
		return x
	}
	return m.Reg
}

// GetMode gets the Mode of the WiFiSettings.
func (m *WiFiSettings) GetMode() (x WiFiSettings_Mode) {
	if m == nil {
		return x
	}
	return m.Mode
}

// GetAuthMode gets the AuthMode of the WiFiSettings.
func (m *WiFiSettings) GetAuthMode() (x WiFiSettings_APAuthMode) {
	if m == nil {
		return x
	}
	return m.AuthMode
}

// GetApChannel gets the ApChannel of the WiFiSettings.
func (m *WiFiSettings) GetApChannel() (x uint32) {
	if m == nil {
		return x
	}
	return m.ApChannel
}

// GetBssCfgAP gets the BssCfgAP of the WiFiSettings.
func (m *WiFiSettings) GetBssCfgAP() (x *BSSCfg) {
	if m == nil {
		return x
	}
	return m.BssCfgAP
}

// GetBssCfgClient gets the BssCfgClient of the WiFiSettings.
func (m *WiFiSettings) GetBssCfgClient() (x *BSSCfg) {
	if m == nil {
		return x
	}
	return m.BssCfgClient
}

// GetApHideSsid gets the ApHideSsid of the WiFiSettings.
func (m *WiFiSettings) GetApHideSsid() (x bool) {
	if m == nil {
		return x
	}
	return m.ApHideSsid
}

// GetDisableNexmon gets the DisableNexmon of the WiFiSettings.
func (m *WiFiSettings) GetDisableNexmon() (x bool) {
	if m == nil {
		return x
	}
	return m.DisableNexmon
}

// MarshalToWriter marshals WiFiSettings to the provided writer.
func (m *WiFiSettings) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if m.Disabled {
		writer.WriteBool(1, m.Disabled)
	}

	if len(m.Reg) > 0 {
		writer.WriteString(2, m.Reg)
	}

	if int(m.Mode) != 0 {
		writer.WriteEnum(3, int(m.Mode))
	}

	if int(m.AuthMode) != 0 {
		writer.WriteEnum(4, int(m.AuthMode))
	}

	if m.ApChannel != 0 {
		writer.WriteUint32(5, m.ApChannel)
	}

	if m.BssCfgAP != nil {
		writer.WriteMessage(6, func() {
			m.BssCfgAP.MarshalToWriter(writer)
		})
	}

	if m.BssCfgClient != nil {
		writer.WriteMessage(7, func() {
			m.BssCfgClient.MarshalToWriter(writer)
		})
	}

	if m.ApHideSsid {
		writer.WriteBool(8, m.ApHideSsid)
	}

	if m.DisableNexmon {
		writer.WriteBool(10, m.DisableNexmon)
	}

	return
}

// Marshal marshals WiFiSettings to a slice of bytes.
func (m *WiFiSettings) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a WiFiSettings from the provided reader.
func (m *WiFiSettings) UnmarshalFromReader(reader jspb.Reader) *WiFiSettings {
	for reader.Next() {
		if m == nil {
			m = &WiFiSettings{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.Disabled = reader.ReadBool()
		case 2:
			m.Reg = reader.ReadString()
		case 3:
			m.Mode = WiFiSettings_Mode(reader.ReadEnum())
		case 4:
			m.AuthMode = WiFiSettings_APAuthMode(reader.ReadEnum())
		case 5:
			m.ApChannel = reader.ReadUint32()
		case 6:
			reader.ReadMessage(func() {
				m.BssCfgAP = m.BssCfgAP.UnmarshalFromReader(reader)
			})
		case 7:
			reader.ReadMessage(func() {
				m.BssCfgClient = m.BssCfgClient.UnmarshalFromReader(reader)
			})
		case 8:
			m.ApHideSsid = reader.ReadBool()
		case 10:
			m.DisableNexmon = reader.ReadBool()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a WiFiSettings from a slice of bytes.
func (m *WiFiSettings) Unmarshal(rawBytes []byte) (*WiFiSettings, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type BSSCfg struct {
	SSID string
	PSK  string
}

// GetSSID gets the SSID of the BSSCfg.
func (m *BSSCfg) GetSSID() (x string) {
	if m == nil {
		return x
	}
	return m.SSID
}

// GetPSK gets the PSK of the BSSCfg.
func (m *BSSCfg) GetPSK() (x string) {
	if m == nil {
		return x
	}
	return m.PSK
}

// MarshalToWriter marshals BSSCfg to the provided writer.
func (m *BSSCfg) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	if len(m.SSID) > 0 {
		writer.WriteString(1, m.SSID)
	}

	if len(m.PSK) > 0 {
		writer.WriteString(2, m.PSK)
	}

	return
}

// Marshal marshals BSSCfg to a slice of bytes.
func (m *BSSCfg) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a BSSCfg from the provided reader.
func (m *BSSCfg) UnmarshalFromReader(reader jspb.Reader) *BSSCfg {
	for reader.Next() {
		if m == nil {
			m = &BSSCfg{}
		}

		switch reader.GetFieldNumber() {
		case 1:
			m.SSID = reader.ReadString()
		case 2:
			m.PSK = reader.ReadString()
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a BSSCfg from a slice of bytes.
func (m *BSSCfg) Unmarshal(rawBytes []byte) (*BSSCfg, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

type Empty struct {
}

// MarshalToWriter marshals Empty to the provided writer.
func (m *Empty) MarshalToWriter(writer jspb.Writer) {
	if m == nil {
		return
	}

	return
}

// Marshal marshals Empty to a slice of bytes.
func (m *Empty) Marshal() []byte {
	writer := jspb.NewWriter()
	m.MarshalToWriter(writer)
	return writer.GetResult()
}

// UnmarshalFromReader unmarshals a Empty from the provided reader.
func (m *Empty) UnmarshalFromReader(reader jspb.Reader) *Empty {
	for reader.Next() {
		if m == nil {
			m = &Empty{}
		}

		switch reader.GetFieldNumber() {
		default:
			reader.SkipField()
		}
	}

	return m
}

// Unmarshal unmarshals a Empty from a slice of bytes.
func (m *Empty) Unmarshal(rawBytes []byte) (*Empty, error) {
	reader := jspb.NewReader(rawBytes)

	m = m.UnmarshalFromReader(reader)

	if err := reader.Err(); err != nil {
		return nil, err
	}

	return m, nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpcweb.Client

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpcweb package it is being compiled against.
const _ = grpcweb.GrpcWebPackageIsVersion3

// Client API for P4WNP1 service

type P4WNP1Client interface {
	GetDeployedGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	DeployGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	GetGadgetSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	SetGadgetSettings(ctx context.Context, in *GadgetSettings, opts ...grpcweb.CallOption) (*GadgetSettings, error)
	GetLEDSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*LEDSettings, error)
	SetLEDSettings(ctx context.Context, in *LEDSettings, opts ...grpcweb.CallOption) (*Empty, error)
	MountUMSFile(ctx context.Context, in *GadgetSettingsUMS, opts ...grpcweb.CallOption) (*Empty, error)
	DeployEthernetInterfaceSettings(ctx context.Context, in *EthernetInterfaceSettings, opts ...grpcweb.CallOption) (*Empty, error)
	DeployWifiSettings(ctx context.Context, in *WiFiSettings, opts ...grpcweb.CallOption) (*Empty, error)
	HIDRunScript(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptResult, error)
	HIDRunScriptJob(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptJob, error)
	HIDGetScriptJobResult(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*HIDScriptResult, error)
	HIDCancelScriptJob(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*Empty, error)
	FSWriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpcweb.CallOption) (*Empty, error)
	FSReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpcweb.CallOption) (*ReadFileResponse, error)
	FSGetFileInfo(ctx context.Context, in *FileInfoRequest, opts ...grpcweb.CallOption) (*FileInfoResponse, error)
	FSCreateTempDirOrFile(ctx context.Context, in *TempDirOrFileRequest, opts ...grpcweb.CallOption) (*TempDirOrFileResponse, error)
}

type p4WNP1Client struct {
	client *grpcweb.Client
}

// NewP4WNP1Client creates a new gRPC-Web client.
func NewP4WNP1Client(hostname string, opts ...grpcweb.DialOption) P4WNP1Client {
	return &p4WNP1Client{
		client: grpcweb.NewClient(hostname, "P4wnP1_grpc.P4WNP1", opts...),
	}
}

func (c *p4WNP1Client) GetDeployedGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetDeployedGadgetSetting", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployGadgetSetting(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "DeployGadgetSetting", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) GetGadgetSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetGadgetSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) SetGadgetSettings(ctx context.Context, in *GadgetSettings, opts ...grpcweb.CallOption) (*GadgetSettings, error) {
	resp, err := c.client.RPCCall(ctx, "SetGadgetSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(GadgetSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) GetLEDSettings(ctx context.Context, in *Empty, opts ...grpcweb.CallOption) (*LEDSettings, error) {
	resp, err := c.client.RPCCall(ctx, "GetLEDSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(LEDSettings).Unmarshal(resp)
}

func (c *p4WNP1Client) SetLEDSettings(ctx context.Context, in *LEDSettings, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "SetLEDSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) MountUMSFile(ctx context.Context, in *GadgetSettingsUMS, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "MountUMSFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployEthernetInterfaceSettings(ctx context.Context, in *EthernetInterfaceSettings, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "DeployEthernetInterfaceSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) DeployWifiSettings(ctx context.Context, in *WiFiSettings, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "DeployWifiSettings", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDRunScript(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptResult, error) {
	resp, err := c.client.RPCCall(ctx, "HIDRunScript", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDScriptResult).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDRunScriptJob(ctx context.Context, in *HIDScriptRequest, opts ...grpcweb.CallOption) (*HIDScriptJob, error) {
	resp, err := c.client.RPCCall(ctx, "HIDRunScriptJob", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDScriptJob).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDGetScriptJobResult(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*HIDScriptResult, error) {
	resp, err := c.client.RPCCall(ctx, "HIDGetScriptJobResult", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(HIDScriptResult).Unmarshal(resp)
}

func (c *p4WNP1Client) HIDCancelScriptJob(ctx context.Context, in *HIDScriptJob, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "HIDCancelScriptJob", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) FSWriteFile(ctx context.Context, in *WriteFileRequest, opts ...grpcweb.CallOption) (*Empty, error) {
	resp, err := c.client.RPCCall(ctx, "FSWriteFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(Empty).Unmarshal(resp)
}

func (c *p4WNP1Client) FSReadFile(ctx context.Context, in *ReadFileRequest, opts ...grpcweb.CallOption) (*ReadFileResponse, error) {
	resp, err := c.client.RPCCall(ctx, "FSReadFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(ReadFileResponse).Unmarshal(resp)
}

func (c *p4WNP1Client) FSGetFileInfo(ctx context.Context, in *FileInfoRequest, opts ...grpcweb.CallOption) (*FileInfoResponse, error) {
	resp, err := c.client.RPCCall(ctx, "FSGetFileInfo", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(FileInfoResponse).Unmarshal(resp)
}

func (c *p4WNP1Client) FSCreateTempDirOrFile(ctx context.Context, in *TempDirOrFileRequest, opts ...grpcweb.CallOption) (*TempDirOrFileResponse, error) {
	resp, err := c.client.RPCCall(ctx, "FSCreateTempDirOrFile", in.Marshal(), opts...)
	if err != nil {
		return nil, err
	}

	return new(TempDirOrFileResponse).Unmarshal(resp)
}
